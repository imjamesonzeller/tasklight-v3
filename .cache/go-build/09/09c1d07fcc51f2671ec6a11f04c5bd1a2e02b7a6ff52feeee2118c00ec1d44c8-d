// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/jamesonzeller/go/pkg/mod/github.com/wailsapp/wails/v3@v3.0.0-alpha.9/internal/assetserver/webview/responsewriter_darwin.go:1:1
//go:build darwin

package webview

/*
#cgo CFLAGS: -x objective-c
#cgo LDFLAGS: -framework Foundation -framework WebKit

#import <Foundation/Foundation.h>
#import <WebKit/WebKit.h>

typedef void (^schemeTaskCaller)(id<WKURLSchemeTask>);

static bool urlSchemeTaskCall(void *wkUrlSchemeTask, schemeTaskCaller fn) {
	id<WKURLSchemeTask> urlSchemeTask = (id<WKURLSchemeTask>) wkUrlSchemeTask;
    if (urlSchemeTask == nil) {
        return false;
    }

	@autoreleasepool {
		@try {
			fn(urlSchemeTask);
		} @catch (NSException *exception) {
			// This is very bad to detect a stopped schemeTask this should be implemented in a better way
			// But it seems to be very tricky to not deadlock when keeping a lock curing executing fn()
			// It seems like those call switch the thread back to the main thread and then deadlocks when they reentrant want
			// to get the lock again to start another request or stop it.
			if ([exception.reason isEqualToString: @"This task has already been stopped"]) {
				return false;
			}

			@throw exception;
		}

		return true;
	}
}

static bool URLSchemeTaskDidReceiveData(void *wkUrlSchemeTask, void* data, int datalength) {
	return urlSchemeTaskCall(
		wkUrlSchemeTask,
		^(id<WKURLSchemeTask> urlSchemeTask) {
			NSData *nsdata = [NSData dataWithBytes:data length:datalength];
			[urlSchemeTask didReceiveData:nsdata];
    	});
}

static bool URLSchemeTaskDidFinish(void *wkUrlSchemeTask) {
	return urlSchemeTaskCall(
		wkUrlSchemeTask,
		^(id<WKURLSchemeTask> urlSchemeTask) {
			[urlSchemeTask didFinish];
    	});
}

static bool URLSchemeTaskDidReceiveResponse(void *wkUrlSchemeTask, int statusCode, void *headersString, int headersStringLength) {
	return urlSchemeTaskCall(
		wkUrlSchemeTask,
		^(id<WKURLSchemeTask> urlSchemeTask) {
			NSData *nsHeadersJSON = [NSData dataWithBytes:headersString length:headersStringLength];
			NSDictionary *headerFields = [NSJSONSerialization JSONObjectWithData:nsHeadersJSON options: NSJSONReadingMutableContainers error: nil];
        	NSHTTPURLResponse *response = [[[NSHTTPURLResponse alloc] initWithURL:urlSchemeTask.request.URL statusCode:statusCode HTTPVersion:@"HTTP/1.1" headerFields:headerFields] autorelease];

			[urlSchemeTask didReceiveResponse:response];
    	});
}
*/
import _ "unsafe"

import (
	"encoding/json"
	"net/http"
	"unsafe"
)

var _ ResponseWriter = &responseWriter{}

type responseWriter struct {
	r *request

	header      http.Header
	wroteHeader bool
	code        int

	finished bool
}

func (rw *responseWriter) Header() http.Header {
	if rw.header == nil {
		rw.header = http.Header{}
	}
	return rw.header
}

func (rw *responseWriter) Write(buf []byte) (int, error) {
	if rw.finished {
		return 0, errResponseFinished
	}

	rw.WriteHeader(http.StatusOK)

	var content unsafe.Pointer
	var contentLen int
	if buf != nil {
		content = unsafe.Pointer(&buf[0])
		contentLen = len(buf)
	}

	if !func() _Ctype__Bool{ _cgo0 := /*line :109:36*/rw.r.task; _cgo1 := /*line :109:47*/content; var _cgo2 _Ctype_int = _Ctype_int /*line :109:61*/(contentLen); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :109:74*/_Cfunc_URLSchemeTaskDidReceiveData(_cgo0, _cgo1, _cgo2); }() {
		return 0, errRequestStopped
	}
	return contentLen, nil
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.code = code
	if rw.wroteHeader || rw.finished {
		return
	}
	rw.wroteHeader = true

	header := map[string]string{}
	for k := range rw.Header() {
		header[k] = rw.Header().Get(k)
	}
	headerData, _ := json.Marshal(header)

	var headers unsafe.Pointer
	var headersLen int
	if len(headerData) != 0 {
		headers = unsafe.Pointer(&headerData[0])
		headersLen = len(headerData)
	}

	func() _Ctype__Bool{ _cgo0 := /*line :135:36*/rw.r.task; var _cgo1 _Ctype_int = _Ctype_int /*line :135:52*/(code); _cgo2 := /*line :135:60*/headers; var _cgo3 _Ctype_int = _Ctype_int /*line :135:74*/(headersLen); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :135:87*/_Cfunc_URLSchemeTaskDidReceiveResponse(_cgo0, _cgo1, _cgo2, _cgo3); }()
}

func (rw *responseWriter) Finish() error {
	if !rw.wroteHeader {
		rw.WriteHeader(http.StatusNotImplemented)
	}

	if rw.finished {
		return nil
	}
	rw.finished = true

	func() _Ctype__Bool{ _cgo0 := /*line :148:27*/rw.r.task; _cgoCheckPointer(_cgo0, nil); return /*line :148:37*/_Cfunc_URLSchemeTaskDidFinish(_cgo0); }()

	return nil
}

func (rw *responseWriter) Code() int {
	return rw.code
}
