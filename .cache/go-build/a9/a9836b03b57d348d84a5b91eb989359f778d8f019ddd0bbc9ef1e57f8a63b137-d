// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/jamesonzeller/go/pkg/mod/github.com/wailsapp/wails/v3@v3.0.0-alpha.9/pkg/application/application_darwin.go:1:1
//go:build darwin

package application

/*

#cgo CFLAGS: -mmacosx-version-min=10.13 -x objective-c
#cgo LDFLAGS: -framework Cocoa -mmacosx-version-min=10.13

#include "application_darwin.h"
#include "application_darwin_delegate.h"
#include "webview_window_darwin.h"
#include <stdlib.h>

extern void registerListener(unsigned int event);

#import <Cocoa/Cocoa.h>
#import <Foundation/Foundation.h>

static AppDelegate *appDelegate = nil;

static void init(void) {
    [NSApplication sharedApplication];
    appDelegate = [[AppDelegate alloc] init];
    [NSApp setDelegate:appDelegate];

	[NSEvent addLocalMonitorForEventsMatchingMask:NSEventMaskLeftMouseDown handler:^NSEvent * _Nullable(NSEvent * _Nonnull event) {
		NSWindow* eventWindow = [event window];
		if (eventWindow == nil ) {
			return event;
        }
		WebviewWindowDelegate* windowDelegate = (WebviewWindowDelegate*)[eventWindow delegate];
		if (windowDelegate == nil) {
			return event;
		}
		if ([windowDelegate respondsToSelector:@selector(handleLeftMouseDown:)]) {
			[windowDelegate handleLeftMouseDown:event];
		}
		return event;
	}];

	[NSEvent addLocalMonitorForEventsMatchingMask:NSEventMaskLeftMouseUp handler:^NSEvent * _Nullable(NSEvent * _Nonnull event) {
		NSWindow* eventWindow = [event window];
		if (eventWindow == nil ) {
			return event;
        }
		WebviewWindowDelegate* windowDelegate = (WebviewWindowDelegate*)[eventWindow delegate];
		if (windowDelegate == nil) {
			return event;
		}
		if ([windowDelegate respondsToSelector:@selector(handleLeftMouseUp:)]) {
			[windowDelegate handleLeftMouseUp:eventWindow];
		}
		return event;
	}];

	NSDistributedNotificationCenter *center = [NSDistributedNotificationCenter defaultCenter];
	[center addObserver:appDelegate selector:@selector(themeChanged:) name:@"AppleInterfaceThemeChangedNotification" object:nil];

}

static bool isDarkMode(void) {
	NSUserDefaults* userDefaults = [NSUserDefaults standardUserDefaults];
	if (userDefaults == nil) {
		return false;
	}

	NSString *interfaceStyle = [userDefaults stringForKey:@"AppleInterfaceStyle"];
	if (interfaceStyle == nil) {
		return false;
	}

	return [interfaceStyle isEqualToString:@"Dark"];
}

static void setApplicationShouldTerminateAfterLastWindowClosed(bool shouldTerminate) {
	// Get the NSApp delegate
	AppDelegate *appDelegate = (AppDelegate*)[NSApp delegate];
	// Set the applicationShouldTerminateAfterLastWindowClosed boolean
	appDelegate.shouldTerminateWhenLastWindowClosed = shouldTerminate;
}

static void setActivationPolicy(int policy) {
    [NSApp setActivationPolicy:policy];
}

static void activateIgnoringOtherApps() {
	[NSApp activateIgnoringOtherApps:YES];
}

static void run(void) {
    @autoreleasepool {
        [NSApp run];
        [appDelegate release];
		[NSApp abortModal];
    }
}

// destroyApp destroys the application
static void destroyApp(void) {
	[NSApp terminate:nil];
}

// Set the application menu
static void setApplicationMenu(void *menu) {
	NSMenu *nsMenu = (__bridge NSMenu *)menu;
	[NSApp setMainMenu:menu];
}

// Get the application name
static char* getAppName(void) {
	NSString *appName = [NSRunningApplication currentApplication].localizedName;
	if( appName == nil ) {
		appName = [[NSProcessInfo processInfo] processName];
	}
	return strdup([appName UTF8String]);
}

// get the current window ID
static unsigned int getCurrentWindowID(void) {
	NSWindow *window = [NSApp keyWindow];
	// Get the window delegate
	WebviewWindowDelegate *delegate = (WebviewWindowDelegate*)[window delegate];
	return delegate.windowId;
}

// Set the application icon
static void setApplicationIcon(void *icon, int length) {
    // On main thread
	dispatch_async(dispatch_get_main_queue(), ^{
		NSImage *image = [[NSImage alloc] initWithData:[NSData dataWithBytes:icon length:length]];
		[NSApp setApplicationIconImage:image];
	});
}

// Hide the application
static void hide(void) {
	[NSApp hide:nil];
}

// Show the application
static void show(void) {
	[NSApp unhide:nil];
}

static const char* serializationNSDictionary(void *dict) {
	@autoreleasepool {
		NSDictionary *nsDict = (__bridge NSDictionary *)dict;

		if ([NSJSONSerialization isValidJSONObject:nsDict]) {
			NSError *error;
			NSData *data = [NSJSONSerialization dataWithJSONObject:nsDict options:kNilOptions error:&error];
			NSString *result = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];

			return strdup([result UTF8String]);
		}
	}

	return nil;
}

static void startSingleInstanceListener(const char *uniqueID) {
	// Convert to NSString
	NSString *uid = [NSString stringWithUTF8String:uniqueID];
	[[NSDistributedNotificationCenter defaultCenter] addObserver:appDelegate
          selector:@selector(handleSecondInstanceNotification:) name:uid object:nil];
}
*/
import _ "unsafe"
import (
	"encoding/json"
	"unsafe"

	"github.com/wailsapp/wails/v3/internal/operatingsystem"

	"github.com/wailsapp/wails/v3/internal/assetserver/webview"
	"github.com/wailsapp/wails/v3/pkg/events"
)

type macosApp struct {
	applicationMenu unsafe.Pointer
	parent          *App
}

func (m *macosApp) isDarkMode() bool {
	return bool(( /*line :186:14*/_Cfunc_isDarkMode /*line :186:25*/)())
}

func getNativeApplication() *macosApp {
	return globalApplication.impl.(*macosApp)
}

func (m *macosApp) hide() {
	( /*line :194:2*/_Cfunc_hide /*line :194:7*/)()
}

func (m *macosApp) show() {
	( /*line :198:2*/_Cfunc_show /*line :198:7*/)()
}

func (m *macosApp) on(eventID uint) {
	( /*line :202:2*/_Cfunc_registerListener /*line :202:19*/)( /*line :202:21*/_Ctype_uint /*line :202:27*/(eventID))
}

func (m *macosApp) setIcon(icon []byte) {
	func() { _cgoIndex0 := &/*line :206:39*/icon; _cgo0 := /*line :206:23*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = _Ctype_int /*line :206:54*/(len(icon)); _cgoCheckPointer(_cgo0, *_cgoIndex0); /*line :206:66*/_Cfunc_setApplicationIcon(_cgo0, _cgo1); }()
}

func (m *macosApp) name() string {
	appName := ( /*line :210:13*/_Cfunc_getAppName /*line :210:24*/)()
	defer func() func() { _cgo0 := /*line :211:15*/unsafe.Pointer(appName); return func() { _cgoCheckPointer(_cgo0, nil); /*line :211:39*/_Cfunc_free(_cgo0); }}()()
	return ( /*line :212:9*/_Cfunc_GoString /*line :212:18*/)(appName)
}

func (m *macosApp) getCurrentWindowID() uint {
	return uint(( /*line :216:14*/_Cfunc_getCurrentWindowID /*line :216:33*/)())
}

func (m *macosApp) setApplicationMenu(menu *Menu) {
	if menu == nil {
		// Create a default menu for mac
		menu = DefaultApplicationMenu()
	}
	menu.Update()

	// Convert impl to macosMenu object
	m.applicationMenu = (menu.impl).(*macosMenu).nsMenu
	func() { _cgo0 := /*line :228:23*/m.applicationMenu; _cgoCheckPointer(_cgo0, nil); /*line :228:41*/_Cfunc_setApplicationMenu(_cgo0); }()
}

func (m *macosApp) run() error {
	if m.parent.options.SingleInstance != nil {
		cUniqueID := ( /*line :233:16*/_Cfunc_CString /*line :233:24*/)(m.parent.options.SingleInstance.UniqueID)
		defer func() func() { _cgo0 := /*line :234:16*/unsafe.Pointer(cUniqueID); return func() { _cgoCheckPointer(_cgo0, nil); /*line :234:42*/_Cfunc_free(_cgo0); }}()()
		( /*line :235:3*/_Cfunc_startSingleInstanceListener /*line :235:31*/)(cUniqueID)
	}
	// Add a hook to the ApplicationDidFinishLaunching event
	m.parent.OnApplicationEvent(events.Mac.ApplicationDidFinishLaunching, func(*ApplicationEvent) {
		( /*line :239:3*/_Cfunc_setApplicationShouldTerminateAfterLastWindowClosed /*line :239:54*/)( /*line :239:56*/_Ctype_bool /*line :239:62*/(m.parent.options.Mac.ApplicationShouldTerminateAfterLastWindowClosed))
		( /*line :240:3*/_Cfunc_setActivationPolicy /*line :240:23*/)( /*line :240:25*/_Ctype_int /*line :240:30*/(m.parent.options.Mac.ActivationPolicy))
		( /*line :241:3*/_Cfunc_activateIgnoringOtherApps /*line :241:29*/)()
	})
	m.setupCommonEvents()
	// setup event listeners
	for eventID := range m.parent.applicationEventListeners {
		m.on(eventID)
	}
	( /*line :248:2*/_Cfunc_run /*line :248:6*/)()
	return nil
}

func (m *macosApp) destroy() {
	( /*line :253:2*/_Cfunc_destroyApp /*line :253:13*/)()
}

func (m *macosApp) GetFlags(options Options) map[string]any {
	if options.Flags == nil {
		options.Flags = make(map[string]any)
	}
	return options.Flags
}

func newPlatformApp(app *App) *macosApp {
	( /*line :264:2*/_Cfunc_init /*line :264:7*/)()
	return &macosApp{
		parent: app,
	}
}

//export processApplicationEvent
func processApplicationEvent(eventID  /*line :271:38*/_Ctype_uint /*line :271:44*/, data unsafe.Pointer) {
	event := newApplicationEvent(events.ApplicationEventType(eventID))

	if data != nil {
		dataCStrJSON := func() *_Ctype_char{ _cgo0 := /*line :275:47*/data; _cgoCheckPointer(_cgo0, nil); return /*line :275:52*/_Cfunc_serializationNSDictionary(_cgo0); }()
		if dataCStrJSON != nil {
			defer func() func() { _cgo0 := /*line :277:17*/unsafe.Pointer(dataCStrJSON); return func() { _cgoCheckPointer(_cgo0, nil); /*line :277:46*/_Cfunc_free(_cgo0); }}()()

			dataJSON := ( /*line :279:16*/_Cfunc_GoString /*line :279:25*/)(dataCStrJSON)
			var result map[string]any
			err := json.Unmarshal([]byte(dataJSON), &result)

			if err != nil {
				panic(err)
			}

			event.Context().setData(result)
		}
	}

	switch event.Id {
	case uint(events.Mac.ApplicationDidChangeTheme):
		isDark := globalApplication.IsDarkMode()
		event.Context().setIsDarkMode(isDark)
	}
	applicationEvents <- event
}

//export processWindowEvent
func processWindowEvent(windowID  /*line :300:34*/_Ctype_uint /*line :300:40*/, eventID  /*line :300:50*/_Ctype_uint /*line :300:56*/) {
	windowEvents <- &windowEvent{
		WindowID: uint(windowID),
		EventID:  uint(eventID),
	}
}

//export processMessage
func processMessage(windowID  /*line :308:30*/_Ctype_uint /*line :308:36*/, message * /*line :308:47*/_Ctype_char /*line :308:53*/) {
	windowMessageBuffer <- &windowMessage{
		windowId: uint(windowID),
		message:  ( /*line :311:13*/_Cfunc_GoString /*line :311:22*/)(message),
	}
}

//export processURLRequest
func processURLRequest(windowID  /*line :316:33*/_Ctype_uint /*line :316:39*/, wkUrlSchemeTask unsafe.Pointer) {
	webviewRequests <- &webViewAssetRequest{
		Request:    webview.NewRequest(wkUrlSchemeTask),
		windowId:   uint(windowID),
		windowName: globalApplication.getWindowForID(uint(windowID)).Name(),
	}
}

//export processWindowKeyDownEvent
func processWindowKeyDownEvent(windowID  /*line :325:41*/_Ctype_uint /*line :325:47*/, acceleratorString * /*line :325:68*/_Ctype_char /*line :325:74*/) {
	windowKeyEvents <- &windowKeyEvent{
		windowId:          uint(windowID),
		acceleratorString: ( /*line :328:22*/_Cfunc_GoString /*line :328:31*/)(acceleratorString),
	}
}

//export processDragItems
func processDragItems(windowID  /*line :333:32*/_Ctype_uint /*line :333:38*/, arr ** /*line :333:46*/_Ctype_char /*line :333:52*/, length  /*line :333:61*/_Ctype_int /*line :333:66*/) {
	var filenames []string
	// Convert the C array to a Go slice
	goSlice := (*[1 << 30]* /*line :336:25*/_Ctype_char /*line :336:31*/)(unsafe.Pointer(arr))[:length:length]
	for _, str := range goSlice {
		filenames = append(filenames, ( /*line :338:33*/_Cfunc_GoString /*line :338:42*/)(str))
	}
	windowDragAndDropBuffer <- &dragAndDropMessage{
		windowId:  uint(windowID),
		filenames: filenames,
	}
}

//export processMenuItemClick
func processMenuItemClick(menuID  /*line :347:34*/_Ctype_uint /*line :347:40*/) {
	menuItemClicked <- uint(menuID)
}

//export shouldQuitApplication
func shouldQuitApplication()  /*line :352:30*/_Ctype_bool /*line :352:36*/ {
	// TODO: This should be configurable
	return  /*line :354:9*/_Ctype_bool /*line :354:15*/(globalApplication.shouldQuit())
}

//export cleanup
func cleanup() {
	globalApplication.cleanup()
}

func (a *App) logPlatformInfo() {
	info, err := operatingsystem.Info()
	if err != nil {
		a.error("Error getting OS info: %s", err.Error())
		return
	}

	a.info("Platform Info:", info.AsLogSlice()...)

}

func (a *App) platformEnvironment() map[string]any {
	return map[string]any{}
}

func fatalHandler(errFunc func(error)) {
	return
}

//export HandleOpenFile
func HandleOpenFile(filePath * /*line :382:31*/_Ctype_char /*line :382:37*/) {
	goFilepath := ( /*line :383:16*/_Cfunc_GoString /*line :383:25*/)(filePath)
	// Create new application event context
	eventContext := newApplicationEventContext()
	eventContext.setOpenedWithFile(goFilepath)
	// EmitEvent application started event
	applicationEvents <- &ApplicationEvent{
		Id:  uint(events.Common.ApplicationOpenedWithFile),
		ctx: eventContext,
	}
}
