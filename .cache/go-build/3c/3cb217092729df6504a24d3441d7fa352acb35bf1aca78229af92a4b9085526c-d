// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/jamesonzeller/go/pkg/mod/github.com/wailsapp/wails/v3@v3.0.0-alpha.9/internal/assetserver/webview/request_darwin.go:1:1
//go:build darwin

package webview

/*
#cgo CFLAGS: -x objective-c
#cgo LDFLAGS: -framework Foundation -framework WebKit

#import <Foundation/Foundation.h>
#import <WebKit/WebKit.h>
#include <string.h>

static void URLSchemeTaskRetain(void *wkUrlSchemeTask) {
	id<WKURLSchemeTask> urlSchemeTask = (id<WKURLSchemeTask>) wkUrlSchemeTask;
	[urlSchemeTask retain];
}

static void URLSchemeTaskRelease(void *wkUrlSchemeTask) {
	id<WKURLSchemeTask> urlSchemeTask = (id<WKURLSchemeTask>) wkUrlSchemeTask;
	[urlSchemeTask release];
}

static const char * URLSchemeTaskRequestURL(void *wkUrlSchemeTask) {
	id<WKURLSchemeTask> urlSchemeTask = (id<WKURLSchemeTask>) wkUrlSchemeTask;
	@autoreleasepool {
		return [urlSchemeTask.request.URL.absoluteString UTF8String];
	}
}

static const char * URLSchemeTaskRequestMethod(void *wkUrlSchemeTask) {
	id<WKURLSchemeTask> urlSchemeTask = (id<WKURLSchemeTask>) wkUrlSchemeTask;
	@autoreleasepool {
		return [urlSchemeTask.request.HTTPMethod UTF8String];
	}
}

static const char * URLSchemeTaskRequestHeadersJSON(void *wkUrlSchemeTask) {
	id<WKURLSchemeTask> urlSchemeTask = (id<WKURLSchemeTask>) wkUrlSchemeTask;
	@autoreleasepool {
		NSData *headerData = [NSJSONSerialization dataWithJSONObject: urlSchemeTask.request.allHTTPHeaderFields options:0 error: nil];
		if (!headerData) {
			return nil;
		}

		NSString* headerString = [[[NSString alloc] initWithData:headerData encoding:NSUTF8StringEncoding] autorelease];
		const char * headerJSON = [headerString UTF8String];

		return strdup(headerJSON);
	}
}

static bool URLSchemeTaskRequestBodyBytes(void *wkUrlSchemeTask, const void **body, int *bodyLen) {
	id<WKURLSchemeTask> urlSchemeTask = (id<WKURLSchemeTask>) wkUrlSchemeTask;
	@autoreleasepool {
		if (!urlSchemeTask.request.HTTPBody) {
			return false;
		}

		*body = urlSchemeTask.request.HTTPBody.bytes;
		*bodyLen = urlSchemeTask.request.HTTPBody.length;
		return true;
	}
}

static bool URLSchemeTaskRequestBodyStreamOpen(void *wkUrlSchemeTask) {
	id<WKURLSchemeTask> urlSchemeTask = (id<WKURLSchemeTask>) wkUrlSchemeTask;
	@autoreleasepool {
		if (!urlSchemeTask.request.HTTPBodyStream) {
			return false;
		}

		[urlSchemeTask.request.HTTPBodyStream open];
		return true;
	}
}

static void URLSchemeTaskRequestBodyStreamClose(void *wkUrlSchemeTask) {
	id<WKURLSchemeTask> urlSchemeTask = (id<WKURLSchemeTask>) wkUrlSchemeTask;
	@autoreleasepool {
		if (!urlSchemeTask.request.HTTPBodyStream) {
			return;
		}

		[urlSchemeTask.request.HTTPBodyStream close];
	}
}

static int URLSchemeTaskRequestBodyStreamRead(void *wkUrlSchemeTask, void *buf, int bufLen) {
	id<WKURLSchemeTask> urlSchemeTask = (id<WKURLSchemeTask>) wkUrlSchemeTask;

	@autoreleasepool {
		NSInputStream *stream = urlSchemeTask.request.HTTPBodyStream;
		if (!stream) {
			return -2;
		}

		NSStreamStatus status = stream.streamStatus;
		if (status == NSStreamStatusAtEnd || !stream.hasBytesAvailable) {
			return 0;
		} else if (status != NSStreamStatusOpen) {
			return -3;
		}

		return [stream read:buf maxLength:bufLen];
	}
}
*/
import _ "unsafe"

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"unsafe"
)

// NewRequest creates as new WebViewRequest based on a pointer to an `id<WKURLSchemeTask>`
func NewRequest(wkURLSchemeTask unsafe.Pointer) Request {
	func() { _cgo0 := /*line :121:24*/wkURLSchemeTask; _cgoCheckPointer(_cgo0, nil); /*line :121:40*/_Cfunc_URLSchemeTaskRetain(_cgo0); }()
	return newRequestFinalizer(&request{task: wkURLSchemeTask})
}

var _ Request = &request{}

type request struct {
	task unsafe.Pointer

	header http.Header
	body   io.ReadCloser
	rw     *responseWriter
}

func (r *request) URL() (string, error) {
	return ( /*line :136:9*/_Cfunc_GoString /*line :136:18*/)(func() *_Ctype_char{ _cgo0 := /*line :136:46*/r.task; _cgoCheckPointer(_cgo0, nil); return /*line :136:53*/_Cfunc_URLSchemeTaskRequestURL(_cgo0); }()), nil
}

func (r *request) Method() (string, error) {
	return ( /*line :140:9*/_Cfunc_GoString /*line :140:18*/)(func() *_Ctype_char{ _cgo0 := /*line :140:49*/r.task; _cgoCheckPointer(_cgo0, nil); return /*line :140:56*/_Cfunc_URLSchemeTaskRequestMethod(_cgo0); }()), nil
}

func (r *request) Header() (http.Header, error) {
	if r.header != nil {
		return r.header, nil
	}

	header := http.Header{}
	if cHeaders := func() *_Ctype_char{ _cgo0 := /*line :149:51*/r.task; _cgoCheckPointer(_cgo0, nil); return /*line :149:58*/_Cfunc_URLSchemeTaskRequestHeadersJSON(_cgo0); }(); cHeaders != nil {
		if headers := ( /*line :150:17*/_Cfunc_GoString /*line :150:26*/)(cHeaders); headers != "" {
			var h map[string]string
			if err := json.Unmarshal([]byte(headers), &h); err != nil {
				return nil, fmt.Errorf("unable to unmarshal request headers: %s", err)
			}

			for k, v := range h {
				header.Add(k, v)
			}
		}
		func() { _cgo0 := /*line :160:10*/unsafe.Pointer(cHeaders); _cgoCheckPointer(_cgo0, nil); /*line :160:35*/_Cfunc_free(_cgo0); }()
	}
	r.header = header
	return header, nil
}

func (r *request) Body() (io.ReadCloser, error) {
	if r.body != nil {
		return r.body, nil
	}

	var body unsafe.Pointer
	var bodyLen  /*line :172:14*/_Ctype_int /*line :172:19*/
	if func() _Ctype__Bool{ _cgo0 := /*line :173:37*/r.task; _cgoBase1 := /*line :173:45*/&body; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_int = /*line :173:52*/&bodyLen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :173:61*/_Cfunc_URLSchemeTaskRequestBodyBytes(_cgo0, _cgo1, _cgo2); }() {
		if body != nil && bodyLen > 0 {
			r.body = io.NopCloser(bytes.NewReader(func() []byte{ _cgo0 := /*line :175:52*/body; var _cgo1 _Ctype_int = /*line :175:58*/bodyLen; _cgoCheckPointer(_cgo0, nil); return /*line :175:66*/_Cfunc_GoBytes(_cgo0, _cgo1); }()))
		} else {
			r.body = http.NoBody
		}
	} else if func() _Ctype__Bool{ _cgo0 := /*line :179:49*/r.task; _cgoCheckPointer(_cgo0, nil); return /*line :179:56*/_Cfunc_URLSchemeTaskRequestBodyStreamOpen(_cgo0); }() {
		r.body = &requestBodyStreamReader{task: r.task}
	}

	return r.body, nil
}

func (r *request) Response() ResponseWriter {
	if r.rw != nil {
		return r.rw
	}

	r.rw = &responseWriter{r: r}
	return r.rw
}

func (r *request) Close() error {
	var err error
	if r.body != nil {
		err = r.body.Close()
	}
	r.Response().Finish()
	func() { _cgo0 := /*line :201:25*/r.task; _cgoCheckPointer(_cgo0, nil); /*line :201:32*/_Cfunc_URLSchemeTaskRelease(_cgo0); }()
	return err
}

var _ io.ReadCloser = &requestBodyStreamReader{}

type requestBodyStreamReader struct {
	task   unsafe.Pointer
	closed bool
}

// Read implements io.Reader
func (r *requestBodyStreamReader) Read(p []byte) (n int, err error) {
	var content unsafe.Pointer
	var contentLen int
	if p != nil {
		content = unsafe.Pointer(&p[0])
		contentLen = len(p)
	}

	res := func() _Ctype_int{ _cgo0 := /*line :221:46*/r.task; _cgo1 := /*line :221:54*/content; var _cgo2 _Ctype_int = _Ctype_int /*line :221:68*/(contentLen); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :221:81*/_Cfunc_URLSchemeTaskRequestBodyStreamRead(_cgo0, _cgo1, _cgo2); }()
	if res > 0 {
		return int(res), nil
	}

	switch res {
	case 0:
		return 0, io.EOF
	case -1:
		return 0, fmt.Errorf("body: stream error")
	case -2:
		return 0, fmt.Errorf("body: no stream defined")
	case -3:
		return 0, io.ErrClosedPipe
	default:
		return 0, fmt.Errorf("body: unknown error %d", res)
	}
}

func (r *requestBodyStreamReader) Close() error {
	if r.closed {
		return nil
	}
	r.closed = true

	func() { _cgo0 := /*line :246:40*/r.task; _cgoCheckPointer(_cgo0, nil); /*line :246:47*/_Cfunc_URLSchemeTaskRequestBodyStreamClose(_cgo0); }()
	return nil
}
