// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/jamesonzeller/go/pkg/mod/github.com/wailsapp/wails/v3@v3.0.0-alpha.9/pkg/application/menu_darwin.go:1:1
//go:build darwin

package application

/*
#cgo CFLAGS: -mmacosx-version-min=10.10 -x objective-c
#cgo LDFLAGS: -framework Cocoa

#include "menuitem_darwin.h"

extern void setMenuItemChecked(void*, unsigned int, bool);
extern void setMenuItemBitmap(void*, unsigned char*, int);

// Clear and release all menu items in the menu
void clearMenu(void* nsMenu) {
	NSMenu *menu = (NSMenu *)nsMenu;
	[menu removeAllItems];
}


// Create a new NSMenu
void* createNSMenu(char* label) {
	NSMenu *menu = [[NSMenu alloc] init];
	if( label != NULL && strlen(label) > 0 ) {
		menu.title = [NSString stringWithUTF8String:label];
		free(label);
	}
	[menu setAutoenablesItems:NO];
	return (void*)menu;
}

void addMenuItem(void* nsMenu, void* nsMenuItem) {
	NSMenu *menu = (NSMenu *)nsMenu;
	[menu addItem:nsMenuItem];
}

// add seperator to menu
void addMenuSeparator(void* nsMenu) {
	NSMenu *menu = (NSMenu *)nsMenu;
	[menu addItem:[NSMenuItem separatorItem]];
}

// Set the submenu of a menu item
void setMenuItemSubmenu(void* nsMenuItem, void* nsMenu) {
	NSMenuItem *menuItem = (NSMenuItem *)nsMenuItem;
	NSMenu *menu = (NSMenu *)nsMenu;
	[menuItem setSubmenu:menu];
}

// Add services menu
static void addServicesMenu(void* menu) {
	NSMenu *nsMenu = (__bridge NSMenu *)menu;
	[NSApp setServicesMenu:nsMenu];
}


*/
import _ "unsafe"
import "unsafe"

type macosMenu struct {
	menu *Menu

	nsMenu unsafe.Pointer
}

func newMenuImpl(menu *Menu) *macosMenu {
	result := &macosMenu{
		menu: menu,
	}
	return result
}

func (m *macosMenu) update() {
	if m.nsMenu == nil {
		m.nsMenu = ( /*line :76:14*/_Cfunc_createNSMenu /*line :76:27*/)(( /*line :76:29*/_Cfunc_CString /*line :76:37*/)(m.menu.label))
	} else {
		func() { _cgo0 := /*line :78:15*/m.nsMenu; _cgoCheckPointer(_cgo0, nil); /*line :78:24*/_Cfunc_clearMenu(_cgo0); }()
	}
	m.processMenu(m.nsMenu, m.menu)
}

func (m *macosMenu) processMenu(parent unsafe.Pointer, menu *Menu) {
	for _, item := range menu.items {
		switch item.itemType {
		case submenu:
			submenu := item.submenu
			nsSubmenu := ( /*line :88:17*/_Cfunc_createNSMenu /*line :88:30*/)(( /*line :88:32*/_Cfunc_CString /*line :88:40*/)(item.label))
			m.processMenu(nsSubmenu, submenu)
			menuItem := newMenuItemImpl(item)
			item.impl = menuItem
			func() { _cgo0 := /*line :92:18*/parent; _cgo1 := /*line :92:26*/menuItem.nsMenuItem; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :92:46*/_Cfunc_addMenuItem(_cgo0, _cgo1); }()
			func() { _cgo0 := /*line :93:25*/menuItem.nsMenuItem; _cgo1 := /*line :93:46*/nsSubmenu; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :93:56*/_Cfunc_setMenuItemSubmenu(_cgo0, _cgo1); }()
			if item.role == ServicesMenu {
				func() { _cgo0 := /*line :95:23*/nsSubmenu; _cgoCheckPointer(_cgo0, nil); /*line :95:33*/_Cfunc_addServicesMenu(_cgo0); }()
			}
		case text, checkbox, radio:
			menuItem := newMenuItemImpl(item)
			item.impl = menuItem
			func() { _cgo0 := /*line :100:18*/parent; _cgo1 := /*line :100:26*/menuItem.nsMenuItem; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :100:46*/_Cfunc_addMenuItem(_cgo0, _cgo1); }()
		case separator:
			func() { _cgo0 := /*line :102:23*/parent; _cgoCheckPointer(_cgo0, nil); /*line :102:30*/_Cfunc_addMenuSeparator(_cgo0); }()
		}
		if item.bitmap != nil {
			macMenuItem := item.impl.(*macosMenuItem)
			func() { _cgo0 := /*line :106:24*/macMenuItem.nsMenuItem; var _cgo1 *_Ctype_uchar = /*line :106:48*/(*_Ctype_uchar /*line :106:57*/)(&item.bitmap[0]); var _cgo2 _Ctype_int = _Ctype_int /*line :106:82*/(len(item.bitmap)); _cgoCheckPointer(_cgo0, nil); /*line :106:101*/_Cfunc_setMenuItemBitmap(_cgo0, _cgo1, _cgo2); }()
		}

	}
}

func DefaultApplicationMenu() *Menu {
	menu := NewMenu()
	menu.AddRole(AppMenu)
	menu.AddRole(FileMenu)
	menu.AddRole(EditMenu)
	menu.AddRole(ViewMenu)
	menu.AddRole(WindowMenu)
	menu.AddRole(HelpMenu)
	return menu
}
