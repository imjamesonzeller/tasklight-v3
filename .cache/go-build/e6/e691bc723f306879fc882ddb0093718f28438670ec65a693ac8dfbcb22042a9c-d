// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/jamesonzeller/go/pkg/mod/github.com/wailsapp/wails/v3@v3.0.0-alpha.9/pkg/application/webview_window_darwin.go:1:1
//go:build darwin

package application

/*
#cgo CFLAGS: -mmacosx-version-min=10.13 -x objective-c
#cgo LDFLAGS: -framework Cocoa -framework WebKit

#include "application_darwin.h"
#include "webview_window_darwin.h"
#include <stdlib.h>
#include "Cocoa/Cocoa.h"
#import <WebKit/WebKit.h>
#import <AppKit/AppKit.h>
#import "webview_window_darwin_drag.h"

struct WebviewPreferences {
    bool *TabFocusesLinks;
    bool *TextInteractionEnabled;
    bool *FullscreenEnabled;
};

extern void registerListener(unsigned int event);

// Create a new Window
void* windowNew(unsigned int id, int width, int height, bool fraudulentWebsiteWarningEnabled, bool frameless, bool enableDragAndDrop, struct WebviewPreferences preferences) {
	NSWindowStyleMask styleMask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable | NSWindowStyleMaskResizable;
	if (frameless) {
		styleMask = NSWindowStyleMaskBorderless | NSWindowStyleMaskResizable;
	}
	WebviewWindow* window = [[WebviewWindow alloc] initWithContentRect:NSMakeRect(0, 0, width-1, height-1)
		styleMask:styleMask
		backing:NSBackingStoreBuffered
		defer:NO];

	// Allow fullscreen. Needed for frameless windows
	window.collectionBehavior = NSWindowCollectionBehaviorFullScreenPrimary;

	// Create delegate
	WebviewWindowDelegate* delegate = [[WebviewWindowDelegate alloc] init];
	[delegate autorelease];

	// Set delegate
	[window setDelegate:delegate];
	delegate.windowId = id;

	// Add NSView to window
	NSView* view = [[NSView alloc] initWithFrame:NSMakeRect(0, 0, width-1, height-1)];
	[view autorelease];

	[view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
	if( frameless ) {
		[view setWantsLayer:YES];
		view.layer.cornerRadius = 8.0;
	}
	[window setContentView:view];

	// Embed wkwebview in window
	NSRect frame = NSMakeRect(0, 0, width, height);
	WKWebViewConfiguration* config = [[WKWebViewConfiguration alloc] init];
	[config autorelease];

	// Set preferences
    if (preferences.TabFocusesLinks != NULL) {
		config.preferences.tabFocusesLinks = *preferences.TabFocusesLinks;
	}

#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110300
	if (@available(macOS 11.3, *)) {
		if (preferences.TextInteractionEnabled != NULL) {
			config.preferences.textInteractionEnabled = *preferences.TextInteractionEnabled;
		}
	}
#endif

#if MAC_OS_X_VERSION_MAX_ALLOWED >= 120300
	if (@available(macOS 12.3, *)) {
         if (preferences.FullscreenEnabled != NULL) {
             config.preferences.elementFullscreenEnabled = *preferences.FullscreenEnabled;
         }
     }
#endif

	config.suppressesIncrementalRendering = true;
    config.applicationNameForUserAgent = @"wails.io";
	[config setURLSchemeHandler:delegate forURLScheme:@"wails"];

#if MAC_OS_X_VERSION_MAX_ALLOWED >= 101500
 	if (@available(macOS 10.15, *)) {
         config.preferences.fraudulentWebsiteWarningEnabled = fraudulentWebsiteWarningEnabled;
	}
#endif

	// Setup user content controller
    WKUserContentController* userContentController = [WKUserContentController new];
	[userContentController autorelease];

    [userContentController addScriptMessageHandler:delegate name:@"external"];
    config.userContentController = userContentController;

	WKWebView* webView = [[WKWebView alloc] initWithFrame:frame configuration:config];
	[webView autorelease];

	[view addSubview:webView];

    // support webview events
    [webView setNavigationDelegate:delegate];

	// Ensure webview resizes with the window
	[webView setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];

	if( enableDragAndDrop ) {
		WebviewDrag* dragView = [[WebviewDrag alloc] initWithFrame:NSMakeRect(0, 0, width-1, height-1)];
		[dragView autorelease];

		[view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
		[view addSubview:dragView];
		dragView.windowId = id;
	}

	window.webView = webView;
	return window;
}


void printWindowStyle(void *window) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
    NSWindowStyleMask styleMask = [nsWindow styleMask];
	// Get delegate
	WebviewWindowDelegate* windowDelegate = (WebviewWindowDelegate*)[nsWindow delegate];

	printf("Window %d style mask: ", windowDelegate.windowId);

    if (styleMask & NSWindowStyleMaskTitled)
    {
        printf("NSWindowStyleMaskTitled ");
    }

    if (styleMask & NSWindowStyleMaskClosable)
    {
        printf("NSWindowStyleMaskClosable ");
    }

    if (styleMask & NSWindowStyleMaskMiniaturizable)
    {
        printf("NSWindowStyleMaskMiniaturizable ");
    }

    if (styleMask & NSWindowStyleMaskResizable)
    {
        printf("NSWindowStyleMaskResizable ");
    }

    if (styleMask & NSWindowStyleMaskFullSizeContentView)
    {
        printf("NSWindowStyleMaskFullSizeContentView ");
    }

    if (styleMask & NSWindowStyleMaskNonactivatingPanel)
    {
        printf("NSWindowStyleMaskNonactivatingPanel ");
    }

	if (styleMask & NSWindowStyleMaskFullScreen)
	{
		printf("NSWindowStyleMaskFullScreen ");
	}

	if (styleMask & NSWindowStyleMaskBorderless)
	{
		printf("MSWindowStyleMaskBorderless ");
	}

	printf("\n");
}


// setInvisibleTitleBarHeight sets the invisible title bar height
void setInvisibleTitleBarHeight(void* window, unsigned int height) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
	// Get delegate
	WebviewWindowDelegate* delegate = (WebviewWindowDelegate*)[nsWindow delegate];
	// Set height
	delegate.invisibleTitleBarHeight = height;
}

// Make NSWindow transparent
void windowSetTransparent(void* nsWindow) {
	[(WebviewWindow*)nsWindow setOpaque:NO];
	[(WebviewWindow*)nsWindow setBackgroundColor:[NSColor clearColor]];
}

void windowSetInvisibleTitleBar(void* nsWindow, unsigned int height) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	WebviewWindowDelegate* delegate = (WebviewWindowDelegate*)[window delegate];
	delegate.invisibleTitleBarHeight = height;
}


// Set the title of the NSWindow
void windowSetTitle(void* nsWindow, char* title) {
	NSString* nsTitle = [NSString stringWithUTF8String:title];
	[(WebviewWindow*)nsWindow setTitle:nsTitle];
	free(title);
}

// Set the size of the NSWindow
void windowSetSize(void* nsWindow, int width, int height) {
	// Set window size on main thread
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	NSSize contentSize = [window contentRectForFrameRect:NSMakeRect(0, 0, width, height)].size;
	[window setContentSize:contentSize];
	[window setFrame:NSMakeRect(window.frame.origin.x, window.frame.origin.y, width, height) display:YES animate:YES];
}

// Set NSWindow always on top
void windowSetAlwaysOnTop(void* nsWindow, bool alwaysOnTop) {
	// Set window always on top on main thread
	[(WebviewWindow*)nsWindow setLevel:alwaysOnTop ? NSFloatingWindowLevel : NSNormalWindowLevel];
}

void setNormalWindowLevel(void* nsWindow) { [(WebviewWindow*)nsWindow setLevel:NSNormalWindowLevel]; }
void setFloatingWindowLevel(void* nsWindow) { [(WebviewWindow*)nsWindow setLevel:NSFloatingWindowLevel];}
void setPopUpMenuWindowLevel(void* nsWindow) { [(WebviewWindow*)nsWindow setLevel:NSPopUpMenuWindowLevel]; }
void setMainMenuWindowLevel(void* nsWindow) { [(WebviewWindow*)nsWindow setLevel:NSMainMenuWindowLevel]; }
void setStatusWindowLevel(void* nsWindow) { [(WebviewWindow*)nsWindow setLevel:NSStatusWindowLevel]; }
void setModalPanelWindowLevel(void* nsWindow) { [(WebviewWindow*)nsWindow setLevel:NSModalPanelWindowLevel]; }
void setScreenSaverWindowLevel(void* nsWindow) { [(WebviewWindow*)nsWindow setLevel:NSScreenSaverWindowLevel]; }
void setTornOffMenuWindowLevel(void* nsWindow) { [(WebviewWindow*)nsWindow setLevel:NSTornOffMenuWindowLevel]; }

// Load URL in NSWindow
void navigationLoadURL(void* nsWindow, char* url) {
	// Load URL on main thread
	NSURL* nsURL = [NSURL URLWithString:[NSString stringWithUTF8String:url]];
	NSURLRequest* request = [NSURLRequest requestWithURL:nsURL];
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	[window.webView loadRequest:request];
	free(url);
}

// Set NSWindow resizable
void windowSetResizable(void* nsWindow, bool resizable) {
	// Set window resizable on main thread
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	if (resizable) {
		NSWindowStyleMask styleMask = [window styleMask] | NSWindowStyleMaskResizable;
		[window setStyleMask:styleMask];
	} else {
		NSWindowStyleMask styleMask = [window styleMask] & ~NSWindowStyleMaskResizable;
		[window setStyleMask:styleMask];
	}
}

// Set NSWindow min size
void windowSetMinSize(void* nsWindow, int width, int height) {
	// Set window min size on main thread
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	NSSize contentSize = [window contentRectForFrameRect:NSMakeRect(0, 0, width, height)].size;
	[window setContentMinSize:contentSize];
	NSSize size = { width, height };
	[window setMinSize:size];
}

// Set NSWindow max size
void windowSetMaxSize(void* nsWindow, int width, int height) {
	// Set window max size on main thread
	NSSize size = { FLT_MAX, FLT_MAX };
	size.width = width > 0 ? width : FLT_MAX;
	size.height = height > 0 ? height : FLT_MAX;
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	NSSize contentSize = [window contentRectForFrameRect:NSMakeRect(0, 0, size.width, size.height)].size;
	[window setContentMaxSize:contentSize];
	[window setMaxSize:size];
}

// windowZoomReset
void windowZoomReset(void* nsWindow) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	[window.webView setMagnification:1.0];
}

// windowZoomSet
void windowZoomSet(void* nsWindow, double zoom) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	// Reset zoom
	[window.webView setMagnification:zoom];
}

// windowZoomGet
float windowZoomGet(void* nsWindow) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	// Get zoom
	return [window.webView magnification];
}

// windowZoomIn
void windowZoomIn(void* nsWindow) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	// Zoom in
	[window.webView setMagnification:window.webView.magnification + 0.05];
}

// windowZoomOut
void windowZoomOut(void* nsWindow) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	// Zoom out
	if( window.webView.magnification > 1.05 ) {
		[window.webView setMagnification:window.webView.magnification - 0.05];
	} else {
		[window.webView setMagnification:1.0];
	}
}

// set the window position relative to the screen
void windowSetRelativePosition(void* nsWindow, int x, int y) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	NSScreen* screen = [window screen];
	if( screen == NULL ) {
		screen = [NSScreen mainScreen];
	}
	NSRect windowFrame = [window frame];
	NSRect screenFrame = [screen frame];
	windowFrame.origin.x = screenFrame.origin.x + (float)x;
	windowFrame.origin.y = (screenFrame.origin.y + screenFrame.size.height) - windowFrame.size.height - (float)y;

	[window setFrame:windowFrame display:TRUE animate:FALSE];
}

// Execute JS in NSWindow
void windowExecJS(void* nsWindow, const char* js) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	[window.webView evaluateJavaScript:[NSString stringWithUTF8String:js] completionHandler:nil];
	free((void*)js);
}

// Make NSWindow backdrop translucent
void windowSetTranslucent(void* nsWindow) {
	// Get window
	WebviewWindow* window = (WebviewWindow*)nsWindow;

	id contentView = [window contentView];
	NSVisualEffectView *effectView = [NSVisualEffectView alloc];
	NSRect bounds = [contentView bounds];
	[effectView initWithFrame:bounds];
	[effectView setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
	[effectView setBlendingMode:NSVisualEffectBlendingModeBehindWindow];
	[effectView setState:NSVisualEffectStateActive];
	[contentView addSubview:effectView positioned:NSWindowBelow relativeTo:nil];
}

// Make webview background transparent
void webviewSetTransparent(void* nsWindow) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	// Set webview background transparent
	[window.webView setValue:@NO forKey:@"drawsBackground"];
}

// Set webview background colour
void webviewSetBackgroundColour(void* nsWindow, int r, int g, int b, int alpha) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	// Set webview background color
	[window.webView setValue:[NSColor colorWithRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:alpha/255.0] forKey:@"backgroundColor"];
}

// Set the window background colour
void windowSetBackgroundColour(void* nsWindow, int r, int g, int b, int alpha) {
	[(WebviewWindow*)nsWindow setBackgroundColor:[NSColor colorWithRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:alpha/255.0]];
}

bool windowIsMaximised(void* nsWindow) {
	return [(WebviewWindow*)nsWindow isZoomed];
}

bool windowIsFullscreen(void* nsWindow) {
	return [(WebviewWindow*)nsWindow styleMask] & NSWindowStyleMaskFullScreen;
}

bool windowIsMinimised(void* nsWindow) {
	return [(WebviewWindow*)nsWindow isMiniaturized];
}

bool windowIsFocused(void* nsWindow) {
	return [(WebviewWindow*)nsWindow isKeyWindow];
}

// Set Window fullscreen
void windowFullscreen(void* nsWindow) {
	if( windowIsFullscreen(nsWindow) ) {
		return;
	}
	dispatch_async(dispatch_get_main_queue(), ^{
		[(WebviewWindow*)nsWindow toggleFullScreen:nil];
	});}

void windowUnFullscreen(void* nsWindow) {
	if( !windowIsFullscreen(nsWindow) ) {
		return;
	}
	dispatch_async(dispatch_get_main_queue(), ^{
		[(WebviewWindow*)nsWindow toggleFullScreen:nil];
	});
}

// restore window to normal size
void windowRestore(void* nsWindow) {
	// If window is fullscreen
	if([(WebviewWindow*)nsWindow styleMask] & NSWindowStyleMaskFullScreen) {
		[(WebviewWindow*)nsWindow toggleFullScreen:nil];
	}
	// If window is maximised
	if([(WebviewWindow*)nsWindow isZoomed]) {
		[(WebviewWindow*)nsWindow zoom:nil];
	}
	// If window in minimised
	if([(WebviewWindow*)nsWindow isMiniaturized]) {
		[(WebviewWindow*)nsWindow deminiaturize:nil];
	}
}

// disable window fullscreen button
void setFullscreenButtonEnabled(void* nsWindow, bool enabled) {
	NSButton *fullscreenButton = [(WebviewWindow*)nsWindow standardWindowButton:NSWindowZoomButton];
	fullscreenButton.enabled = enabled;
}

// Set the titlebar style
void windowSetTitleBarAppearsTransparent(void* nsWindow, bool transparent) {
	if( transparent ) {
		[(WebviewWindow*)nsWindow setTitlebarAppearsTransparent:true];
	} else {
		[(WebviewWindow*)nsWindow setTitlebarAppearsTransparent:false];
	}
}

// Set window fullsize content view
void windowSetFullSizeContent(void* nsWindow, bool fullSize) {
	if( fullSize ) {
		[(WebviewWindow*)nsWindow setStyleMask:[(WebviewWindow*)nsWindow styleMask] | NSWindowStyleMaskFullSizeContentView];
	} else {
		[(WebviewWindow*)nsWindow setStyleMask:[(WebviewWindow*)nsWindow styleMask] & ~NSWindowStyleMaskFullSizeContentView];
	}
}

// Set Hide Titlebar
void windowSetHideTitleBar(void* nsWindow, bool hideTitlebar) {
	if( hideTitlebar ) {
		[(WebviewWindow*)nsWindow setStyleMask:[(WebviewWindow*)nsWindow styleMask] & ~NSWindowStyleMaskTitled];
	} else {
		[(WebviewWindow*)nsWindow setStyleMask:[(WebviewWindow*)nsWindow styleMask] | NSWindowStyleMaskTitled];
	}
}

// Set Hide Title in Titlebar
void windowSetHideTitle(void* nsWindow, bool hideTitle) {
	if( hideTitle ) {
		[(WebviewWindow*)nsWindow setTitleVisibility:NSWindowTitleHidden];
	} else {
		[(WebviewWindow*)nsWindow setTitleVisibility:NSWindowTitleVisible];
	}
}

// Set Window use toolbar
void windowSetUseToolbar(void* nsWindow, bool useToolbar) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	if( useToolbar ) {
		NSToolbar *toolbar = [[NSToolbar alloc] initWithIdentifier:@"wails.toolbar"];
		[toolbar autorelease];
		[window setToolbar:toolbar];
	} else {
		[window setToolbar:nil];
	}
}

// Set window toolbar style
void windowSetToolbarStyle(void* nsWindow, int style) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;

#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
	if (@available(macOS 11.0, *)) {
		NSToolbar* toolbar = [window toolbar];
		if ( toolbar == nil ) {
			return;
		}
		[window setToolbarStyle:style];
	}
#endif

}
// Set Hide Toolbar Separator
void windowSetHideToolbarSeparator(void* nsWindow, bool hideSeparator) {
	NSToolbar* toolbar = [(WebviewWindow*)nsWindow toolbar];
	if( toolbar == nil ) {
		return;
	}
	[toolbar setShowsBaselineSeparator:!hideSeparator];
}

// Configure the toolbar auto-hide feature
void windowSetShowToolbarWhenFullscreen(void* window, bool setting) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
	// Get delegate
	WebviewWindowDelegate* delegate = (WebviewWindowDelegate*)[nsWindow delegate];
	// Set height
	delegate.showToolbarWhenFullscreen = setting;
}

// Set Window appearance type
void windowSetAppearanceTypeByName(void* nsWindow, const char *appearanceName) {
	// set window appearance type by name
	// Convert appearance name to NSString
	NSString* appearanceNameString = [NSString stringWithUTF8String:appearanceName];
	// Set appearance
	[(WebviewWindow*)nsWindow setAppearance:[NSAppearance appearanceNamed:appearanceNameString]];

	free((void*)appearanceName);
}

// Center window on current monitor
void windowCenter(void* nsWindow) {
    WebviewWindow* window = (WebviewWindow*)nsWindow;
    NSScreen* screen = [window screen];
    if (screen == NULL) {
        screen = [NSScreen mainScreen];
    }

    NSRect screenFrame = [screen frame];
    NSRect windowFrame = [window frame];

    CGFloat x = screenFrame.origin.x + (screenFrame.size.width - windowFrame.size.width) / 2;
    CGFloat y = screenFrame.origin.y + (screenFrame.size.height - windowFrame.size.height) / 2;

    [window setFrame:NSMakeRect(x, y, windowFrame.size.width, windowFrame.size.height) display:YES];
}


// Get the current size of the window
void windowGetSize(void* nsWindow, int* width, int* height) {
	NSRect frame = [(WebviewWindow*)nsWindow frame];
	*width = frame.size.width;
	*height = frame.size.height;
}

// Get window width
int windowGetWidth(void* nsWindow) {
	return [(WebviewWindow*)nsWindow frame].size.width;
}

// Get window height
int windowGetHeight(void* nsWindow) {
	return [(WebviewWindow*)nsWindow frame].size.height;
}

// Get window position
void windowGetRelativePosition(void* nsWindow, int* x, int* y) {
	WebviewWindow* window = (WebviewWindow*)nsWindow;
	NSRect frame = [window frame];
	*x = frame.origin.x;

	// Translate to screen coordinates so Y=0 is the top of the screen
	NSScreen* screen = [window screen];
	if( screen == NULL ) {
		screen = [NSScreen mainScreen];
	}
	NSRect screenFrame = [screen frame];
	*y = screenFrame.size.height - frame.origin.y - frame.size.height;
}

// Get absolute window position
void windowGetPosition(void* nsWindow, int* x, int* y) {
	NSRect frame = [(WebviewWindow*)nsWindow frame];
	*x = frame.origin.x;
	*y = frame.origin.y;
}

void windowSetPosition(void* nsWindow, int x, int y) {
    WebviewWindow* window = (WebviewWindow*)nsWindow;
    NSScreen* screen = [window screen];
    if (screen == NULL) {
        screen = [NSScreen mainScreen];
    }
	// Get the scale of the screen
	CGFloat scale = [screen backingScaleFactor];
    NSRect frame = [window frame];
	// Scale the position
	frame.origin.x = x / scale;
	frame.origin.y = (screen.frame.size.height - frame.size.height) - (y / scale);
	// Set the frame
	[window setFrame:frame display:YES];
}


// Destroy window
void windowDestroy(void* nsWindow) {
	[(WebviewWindow*)nsWindow close];
}

// Remove drop shadow from window
void windowSetShadow(void* nsWindow, bool hasShadow) {
	[(WebviewWindow*)nsWindow setHasShadow:hasShadow];
}


// windowClose closes the current window
static void windowClose(void *window) {
	[(WebviewWindow*)window close];
}

// windowZoom
static void windowZoom(void *window) {
	[(WebviewWindow*)window zoom:nil];
}

// webviewRenderHTML renders the given HTML
static void windowRenderHTML(void *window, const char *html) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
	// get window delegate
	WebviewWindowDelegate* windowDelegate = (WebviewWindowDelegate*)[nsWindow delegate];
	// render html
	[nsWindow.webView loadHTMLString:[NSString stringWithUTF8String:html] baseURL:nil];
}

static void windowInjectCSS(void *window, const char *css) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
	// inject css
	[nsWindow.webView evaluateJavaScript:[NSString stringWithFormat:@"(function() { var style = document.createElement('style'); style.appendChild(document.createTextNode('%@')); document.head.appendChild(style); })();", [NSString stringWithUTF8String:css]] completionHandler:nil];
	free((void*)css);
}

static void windowMinimise(void *window) {
	[(WebviewWindow*)window miniaturize:nil];
}

// zoom maximizes the window to the screen dimensions
static void windowMaximise(void *window) {
	[(WebviewWindow*)window zoom:nil];
}

static bool isFullScreen(void *window) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
    long mask = [nsWindow styleMask];
    return (mask & NSWindowStyleMaskFullScreen) == NSWindowStyleMaskFullScreen;
}

static bool isVisible(void *window) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
    return (nsWindow.occlusionState & NSWindowOcclusionStateVisible) == NSWindowOcclusionStateVisible;
}

// windowSetFullScreen
static void windowSetFullScreen(void *window, bool fullscreen) {
	if (isFullScreen(window)) {
		return;
	}
	WebviewWindow* nsWindow = (WebviewWindow*)window;
	windowSetMaxSize(nsWindow, 0, 0);
	windowSetMinSize(nsWindow, 0, 0);
	[nsWindow toggleFullScreen:nil];
}

// windowUnminimise
static void windowUnminimise(void *window) {
	[(WebviewWindow*)window deminiaturize:nil];
}

// windowUnmaximise
static void windowUnmaximise(void *window) {
	[(WebviewWindow*)window zoom:nil];
}

static void windowDisableSizeConstraints(void *window) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
	// disable size constraints
	[nsWindow setContentMinSize:CGSizeZero];
	[nsWindow setContentMaxSize:CGSizeZero];
}

static void windowShow(void *window) {
	[(WebviewWindow*)window makeKeyAndOrderFront:nil];
}

static void windowHide(void *window) {
	[(WebviewWindow*)window orderOut:nil];
}

// setButtonState sets the state of the given button
// 0 = enabled
// 1 = disabled
// 2 = hidden
static void setButtonState(void *button, int state) {
	if (button == nil) {
		return;
	}
	NSButton *nsbutton = (NSButton*)button;
	nsbutton.hidden = state == 2;
	nsbutton.enabled = state != 1;
}

// setMinimiseButtonState sets the minimise button state
static void setMinimiseButtonState(void *window, int state) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
	NSButton *minimiseButton = [nsWindow standardWindowButton:NSWindowMiniaturizeButton];
	setButtonState(minimiseButton, state);
}

// setMaximiseButtonState sets the maximise button state
static void setMaximiseButtonState(void *window, int state) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
	NSButton *maximiseButton = [nsWindow standardWindowButton:NSWindowZoomButton];
	setButtonState(maximiseButton, state);
}

// setCloseButtonState sets the close button state
static void setCloseButtonState(void *window, int state) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
	NSButton *closeButton = [nsWindow standardWindowButton:NSWindowCloseButton];
	setButtonState(closeButton, state);
}

// windowShowMenu opens an NSMenu at the given coordinates
static void windowShowMenu(void *window, void *menu, int x, int y) {
	NSMenu* nsMenu = (NSMenu*)menu;
	WKWebView* webView = ((WebviewWindow*)window).webView;
	NSPoint point = NSMakePoint(x, y);
	[nsMenu popUpMenuPositioningItem:nil atLocation:point inView:webView];
}

// Make the given window frameless
static void windowSetFrameless(void *window, bool frameless) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
	// set the window style to be frameless
	if (frameless) {
		[nsWindow setStyleMask:([nsWindow styleMask] | NSWindowStyleMaskFullSizeContentView)];
	} else {
		[nsWindow setStyleMask:([nsWindow styleMask] & ~NSWindowStyleMaskFullSizeContentView)];
	}
}

static void startDrag(void *window) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;

	// Get delegate
	WebviewWindowDelegate* windowDelegate = (WebviewWindowDelegate*)[nsWindow delegate];

	// start drag
	[windowDelegate startDrag:nsWindow];
}

// Credit: https://stackoverflow.com/q/33319295
static void windowPrint(void *window) {
#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
	// Check if macOS 11.0 or newer
	if (@available(macOS 11.0, *)) {
		WebviewWindow* nsWindow = (WebviewWindow*)window;
		WebviewWindowDelegate* windowDelegate = (WebviewWindowDelegate*)[nsWindow delegate];
		WKWebView* webView = nsWindow.webView;

		// TODO: Think about whether to expose this as config
		NSPrintInfo *pInfo = [NSPrintInfo sharedPrintInfo];
		pInfo.horizontalPagination = NSPrintingPaginationModeAutomatic;
		pInfo.verticalPagination = NSPrintingPaginationModeAutomatic;
		pInfo.verticallyCentered = YES;
		pInfo.horizontallyCentered = YES;
		pInfo.orientation = NSPaperOrientationLandscape;
		pInfo.leftMargin = 30;
		pInfo.rightMargin = 30;
		pInfo.topMargin = 30;
		pInfo.bottomMargin = 30;

		NSPrintOperation *po = [webView printOperationWithPrintInfo:pInfo];
		po.showsPrintPanel = YES;
		po.showsProgressPanel = YES;

		// Without the next line you get an exception. Also it seems to
		// completely ignore the values in the rect. I tried changing them
		// in both x and y direction to include content scrolled off screen.
		// It had no effect whatsoever in either direction.
		po.view.frame = webView.bounds;

		// [printOperation runOperation] DOES NOT WORK WITH WKWEBVIEW, use
		[po runOperationModalForWindow:window delegate:windowDelegate didRunSelector:nil contextInfo:nil];
	}
#endif
}

void setWindowEnabled(void *window, bool enabled) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
	[nsWindow setIgnoresMouseEvents:!enabled];
}

void windowSetEnabled(void *window, bool enabled) {
	// TODO: Implement
}

void windowFocus(void *window) {
	WebviewWindow* nsWindow = (WebviewWindow*)window;
	// If the current application is not active, activate it
	if (![[NSApplication sharedApplication] isActive]) {
		[[NSApplication sharedApplication] activateIgnoringOtherApps:YES];
	}
	[nsWindow makeKeyAndOrderFront:nil];
	[nsWindow makeKeyWindow];
}

static bool isIgnoreMouseEvents(void *nsWindow) {
    NSWindow *window = (__bridge NSWindow *)nsWindow;
    return [window ignoresMouseEvents];
}

static void setIgnoreMouseEvents(void *nsWindow, bool ignore) {
    NSWindow *window = (__bridge NSWindow *)nsWindow;
    [window setIgnoresMouseEvents:ignore];
}

*/
import _ "unsafe"
import (
	"sync"
	"unsafe"

	"github.com/wailsapp/wails/v3/internal/assetserver"
	"github.com/wailsapp/wails/v3/internal/runtime"

	"github.com/wailsapp/wails/v3/pkg/events"
)

type macosWebviewWindow struct {
	nsWindow unsafe.Pointer
	parent   *WebviewWindow
}

func (w *macosWebviewWindow) handleKeyEvent(acceleratorString string) {
	// Parse acceleratorString
	accelerator, err := parseAccelerator(acceleratorString)
	if err != nil {
		globalApplication.error("unable to parse accelerator: %s", err.Error())
		return
	}
	w.parent.processKeyBinding(accelerator.String())
}

func (w *macosWebviewWindow) getBorderSizes() *LRTB {
	return &LRTB{}
}

func (w *macosWebviewWindow) isFocused() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :846:32*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); return /*line :846:43*/_Cfunc_windowIsFocused(_cgo0); }())
}

func (w *macosWebviewWindow) setPosition(x int, y int) {
	func() { _cgo0 := /*line :850:22*/w.nsWindow; var _cgo1 _Ctype_int = _Ctype_int /*line :850:39*/(x); var _cgo2 _Ctype_int = _Ctype_int /*line :850:49*/(y); _cgoCheckPointer(_cgo0, nil); /*line :850:53*/_Cfunc_windowSetPosition(_cgo0, _cgo1, _cgo2); }()
}

func (w *macosWebviewWindow) print() error {
	func() { _cgo0 := /*line :854:16*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :854:27*/_Cfunc_windowPrint(_cgo0); }()
	return nil
}

func (w *macosWebviewWindow) startResize(_ string) error {
	// Never called. Handled natively by the OS.
	return nil
}

func (w *macosWebviewWindow) focus() {
	// Make the window key and main
	func() { _cgo0 := /*line :865:16*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :865:27*/_Cfunc_windowFocus(_cgo0); }()
}

func (w *macosWebviewWindow) openContextMenu(menu *Menu, data *ContextMenuData) {
	// Create the menu
	thisMenu := newMenuImpl(menu)
	thisMenu.update()
	func() { _cgo0 := /*line :872:19*/w.nsWindow; _cgo1 := /*line :872:31*/thisMenu.nsMenu; var _cgo2 _Ctype_int = _Ctype_int /*line :872:53*/(data.X); var _cgo3 _Ctype_int = _Ctype_int /*line :872:68*/(data.Y); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :872:77*/_Cfunc_windowShowMenu(_cgo0, _cgo1, _cgo2, _cgo3); }()
}

func (w *macosWebviewWindow) getZoom() float64 {
	return float64(func() _Ctype_float{ _cgo0 := /*line :876:33*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); return /*line :876:44*/_Cfunc_windowZoomGet(_cgo0); }())
}

func (w *macosWebviewWindow) setZoom(zoom float64) {
	func() { _cgo0 := /*line :880:18*/w.nsWindow; var _cgo1 _Ctype_double = _Ctype_double /*line :880:38*/(zoom); _cgoCheckPointer(_cgo0, nil); /*line :880:45*/_Cfunc_windowZoomSet(_cgo0, _cgo1); }()
}

func (w *macosWebviewWindow) setFrameless(frameless bool) {
	func() { _cgo0 := /*line :884:23*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :884:41*/(frameless); _cgoCheckPointer(_cgo0, nil); /*line :884:53*/_Cfunc_windowSetFrameless(_cgo0, _cgo1); }()
	if frameless {
		func() { _cgo0 := /*line :886:41*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :886:59*/(true); _cgoCheckPointer(_cgo0, nil); /*line :886:66*/_Cfunc_windowSetTitleBarAppearsTransparent(_cgo0, _cgo1); }()
		func() { _cgo0 := /*line :887:24*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :887:42*/(true); _cgoCheckPointer(_cgo0, nil); /*line :887:49*/_Cfunc_windowSetHideTitle(_cgo0, _cgo1); }()
	} else {
		macOptions := w.parent.options.Mac
		appearsTransparent := macOptions.TitleBar.AppearsTransparent
		hideTitle := macOptions.TitleBar.HideTitle
		func() { _cgo0 := /*line :892:41*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :892:59*/(appearsTransparent); _cgoCheckPointer(_cgo0, nil); /*line :892:80*/_Cfunc_windowSetTitleBarAppearsTransparent(_cgo0, _cgo1); }()
		func() { _cgo0 := /*line :893:24*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :893:42*/(hideTitle); _cgoCheckPointer(_cgo0, nil); /*line :893:54*/_Cfunc_windowSetHideTitle(_cgo0, _cgo1); }()
	}
}

func (w *macosWebviewWindow) setHasShadow(hasShadow bool) {
	func() { _cgo0 := /*line :898:20*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :898:38*/(hasShadow); _cgoCheckPointer(_cgo0, nil); /*line :898:50*/_Cfunc_windowSetShadow(_cgo0, _cgo1); }()
}

func (w *macosWebviewWindow) getScreen() (*Screen, error) {
	return getScreenForWindow(w)
}

func (w *macosWebviewWindow) show() {
	func() { _cgo0 := /*line :906:15*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :906:26*/_Cfunc_windowShow(_cgo0); }()
}

func (w *macosWebviewWindow) hide() {
	func() { _cgo0 := /*line :910:15*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :910:26*/_Cfunc_windowHide(_cgo0); }()
}

func (w *macosWebviewWindow) setFullscreenButtonEnabled(enabled bool) {
	func() { _cgo0 := /*line :914:31*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :914:49*/(enabled); _cgoCheckPointer(_cgo0, nil); /*line :914:59*/_Cfunc_setFullscreenButtonEnabled(_cgo0, _cgo1); }()
}

func (w *macosWebviewWindow) disableSizeConstraints() {
	func() { _cgo0 := /*line :918:33*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :918:44*/_Cfunc_windowDisableSizeConstraints(_cgo0); }()
}

func (w *macosWebviewWindow) unfullscreen() {
	func() { _cgo0 := /*line :922:23*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :922:34*/_Cfunc_windowUnFullscreen(_cgo0); }()
}

func (w *macosWebviewWindow) fullscreen() {
	func() { _cgo0 := /*line :926:21*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :926:32*/_Cfunc_windowFullscreen(_cgo0); }()
}

func (w *macosWebviewWindow) unminimise() {
	func() { _cgo0 := /*line :930:21*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :930:32*/_Cfunc_windowUnminimise(_cgo0); }()
}

func (w *macosWebviewWindow) unmaximise() {
	func() { _cgo0 := /*line :934:21*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :934:32*/_Cfunc_windowUnmaximise(_cgo0); }()
}

func (w *macosWebviewWindow) maximise() {
	func() { _cgo0 := /*line :938:19*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :938:30*/_Cfunc_windowMaximise(_cgo0); }()
}

func (w *macosWebviewWindow) minimise() {
	func() { _cgo0 := /*line :942:19*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :942:30*/_Cfunc_windowMinimise(_cgo0); }()
}

func (w *macosWebviewWindow) on(eventID uint) {
	//C.registerListener(C.uint(eventID))
}

func (w *macosWebviewWindow) zoom() {
	func() { _cgo0 := /*line :950:15*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :950:26*/_Cfunc_windowZoom(_cgo0); }()
}

func (w *macosWebviewWindow) windowZoom() {
	func() { _cgo0 := /*line :954:15*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :954:26*/_Cfunc_windowZoom(_cgo0); }()
}

func (w *macosWebviewWindow) close() {
	func() { _cgo0 := /*line :958:16*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :958:27*/_Cfunc_windowClose(_cgo0); }()
	// TODO: Check if we need to unregister the window here or not
}

func (w *macosWebviewWindow) zoomIn() {
	func() { _cgo0 := /*line :963:17*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :963:28*/_Cfunc_windowZoomIn(_cgo0); }()
}

func (w *macosWebviewWindow) zoomOut() {
	func() { _cgo0 := /*line :967:18*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :967:29*/_Cfunc_windowZoomOut(_cgo0); }()
}

func (w *macosWebviewWindow) zoomReset() {
	func() { _cgo0 := /*line :971:20*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :971:31*/_Cfunc_windowZoomReset(_cgo0); }()
}

func (w *macosWebviewWindow) reload() {
	//TODO: Implement
	globalApplication.debug("reload called on WebviewWindow", "parentID", w.parent.id)
}

func (w *macosWebviewWindow) forceReload() {
	//TODO: Implement
	globalApplication.debug("force reload called on WebviewWindow", "parentID", w.parent.id)
}

func (w *macosWebviewWindow) center() {
	func() { _cgo0 := /*line :985:17*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :985:28*/_Cfunc_windowCenter(_cgo0); }()
}

func (w *macosWebviewWindow) isMinimised() bool {
	return w.syncMainThreadReturningBool(func() bool {
		return bool(func() _Ctype__Bool{ _cgo0 := /*line :990:35*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); return /*line :990:46*/_Cfunc_windowIsMinimised(_cgo0); }())
	})
}

func (w *macosWebviewWindow) isMaximised() bool {
	return w.syncMainThreadReturningBool(func() bool {
		return bool(func() _Ctype__Bool{ _cgo0 := /*line :996:35*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); return /*line :996:46*/_Cfunc_windowIsMaximised(_cgo0); }())
	})
}

func (w *macosWebviewWindow) isFullscreen() bool {
	return w.syncMainThreadReturningBool(func() bool {
		return bool(func() _Ctype__Bool{ _cgo0 := /*line :1002:36*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); return /*line :1002:47*/_Cfunc_windowIsFullscreen(_cgo0); }())
	})
}

func (w *macosWebviewWindow) isNormal() bool {
	return !w.isMinimised() && !w.isMaximised() && !w.isFullscreen()
}

func (w *macosWebviewWindow) isVisible() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :1011:26*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); return /*line :1011:37*/_Cfunc_isVisible(_cgo0); }())
}

func (w *macosWebviewWindow) syncMainThreadReturningBool(fn func() bool) bool {
	var wg sync.WaitGroup
	wg.Add(1)
	var result bool
	globalApplication.dispatchOnMainThread(func() {
		result = fn()
		wg.Done()
	})
	wg.Wait()
	return result
}

func (w *macosWebviewWindow) restore() {
	// restore window to normal size
	func() { _cgo0 := /*line :1028:18*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1028:29*/_Cfunc_windowRestore(_cgo0); }()
}

func (w *macosWebviewWindow) restoreWindow() {
	func() { _cgo0 := /*line :1032:18*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1032:29*/_Cfunc_windowRestore(_cgo0); }()
}

func (w *macosWebviewWindow) setEnabled(enabled bool) {
	func() { _cgo0 := /*line :1036:21*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :1036:39*/(enabled); _cgoCheckPointer(_cgo0, nil); /*line :1036:49*/_Cfunc_windowSetEnabled(_cgo0, _cgo1); }()
}

func (w *macosWebviewWindow) execJS(js string) {
	InvokeAsync(func() {
		if globalApplication.performingShutdown {
			return
		}
		if w.nsWindow == nil {
			return
		}
		func() { _cgo0 := /*line :1047:18*/w.nsWindow; var _cgo1 *_Ctype_char = _Cfunc_CString /*line :1047:39*/(js); _cgoCheckPointer(_cgo0, nil); /*line :1047:44*/_Cfunc_windowExecJS(_cgo0, _cgo1); }()
	})
}

func (w *macosWebviewWindow) setURL(uri string) {
	func() { _cgo0 := /*line :1052:22*/w.nsWindow; var _cgo1 *_Ctype_char = _Cfunc_CString /*line :1052:43*/(uri); _cgoCheckPointer(_cgo0, nil); /*line :1052:49*/_Cfunc_navigationLoadURL(_cgo0, _cgo1); }()
}

func (w *macosWebviewWindow) setAlwaysOnTop(alwaysOnTop bool) {
	func() { _cgo0 := /*line :1056:25*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :1056:43*/(alwaysOnTop); _cgoCheckPointer(_cgo0, nil); /*line :1056:57*/_Cfunc_windowSetAlwaysOnTop(_cgo0, _cgo1); }()
}

func newWindowImpl(parent *WebviewWindow) *macosWebviewWindow {
	result := &macosWebviewWindow{
		parent: parent,
	}
	result.parent.RegisterHook(events.Mac.WebViewDidFinishNavigation, func(event *WindowEvent) {
		result.execJS(runtime.Core())
	})
	return result
}

func (w *macosWebviewWindow) setTitle(title string) {
	if !w.parent.options.Frameless {
		cTitle := ( /*line :1071:13*/_Cfunc_CString /*line :1071:21*/)(title)
		func() { _cgo0 := /*line :1072:20*/w.nsWindow; var _cgo1 *_Ctype_char = /*line :1072:32*/cTitle; _cgoCheckPointer(_cgo0, nil); /*line :1072:39*/_Cfunc_windowSetTitle(_cgo0, _cgo1); }()
	}
}

func (w *macosWebviewWindow) flash(_ bool) {
	// Not supported on macOS
}

func (w *macosWebviewWindow) setSize(width, height int) {
	func() { _cgo0 := /*line :1081:18*/w.nsWindow; var _cgo1 _Ctype_int = _Ctype_int /*line :1081:35*/(width); var _cgo2 _Ctype_int = _Ctype_int /*line :1081:49*/(height); _cgoCheckPointer(_cgo0, nil); /*line :1081:58*/_Cfunc_windowSetSize(_cgo0, _cgo1, _cgo2); }()
}

func (w *macosWebviewWindow) setMinSize(width, height int) {
	func() { _cgo0 := /*line :1085:21*/w.nsWindow; var _cgo1 _Ctype_int = _Ctype_int /*line :1085:38*/(width); var _cgo2 _Ctype_int = _Ctype_int /*line :1085:52*/(height); _cgoCheckPointer(_cgo0, nil); /*line :1085:61*/_Cfunc_windowSetMinSize(_cgo0, _cgo1, _cgo2); }()
}
func (w *macosWebviewWindow) setMaxSize(width, height int) {
	func() { _cgo0 := /*line :1088:21*/w.nsWindow; var _cgo1 _Ctype_int = _Ctype_int /*line :1088:38*/(width); var _cgo2 _Ctype_int = _Ctype_int /*line :1088:52*/(height); _cgoCheckPointer(_cgo0, nil); /*line :1088:61*/_Cfunc_windowSetMaxSize(_cgo0, _cgo1, _cgo2); }()
}

func (w *macosWebviewWindow) setResizable(resizable bool) {
	func() { _cgo0 := /*line :1092:23*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :1092:41*/(resizable); _cgoCheckPointer(_cgo0, nil); /*line :1092:53*/_Cfunc_windowSetResizable(_cgo0, _cgo1); }()
}

func (w *macosWebviewWindow) size() (int, int) {
	var width, height  /*line :1096:20*/_Ctype_int /*line :1096:25*/
	var wg sync.WaitGroup
	wg.Add(1)
	globalApplication.dispatchOnMainThread(func() {
		func() { _cgo0 := /*line :1100:19*/w.nsWindow; var _cgo1 *_Ctype_int = /*line :1100:31*/&width; var _cgo2 *_Ctype_int = /*line :1100:39*/&height; _cgoCheckPointer(_cgo0, nil); /*line :1100:47*/_Cfunc_windowGetSize(_cgo0, _cgo1, _cgo2); }()
		wg.Done()
	})
	wg.Wait()
	return int(width), int(height)
}

func (w *macosWebviewWindow) setRelativePosition(x, y int) {
	func() { _cgo0 := /*line :1108:30*/w.nsWindow; var _cgo1 _Ctype_int = _Ctype_int /*line :1108:47*/(x); var _cgo2 _Ctype_int = _Ctype_int /*line :1108:57*/(y); _cgoCheckPointer(_cgo0, nil); /*line :1108:61*/_Cfunc_windowSetRelativePosition(_cgo0, _cgo1, _cgo2); }()
}

func (w *macosWebviewWindow) setWindowLevel(level MacWindowLevel) {
	switch level {
	case MacWindowLevelNormal:
		func() { _cgo0 := /*line :1114:26*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1114:37*/_Cfunc_setNormalWindowLevel(_cgo0); }()
	case MacWindowLevelFloating:
		func() { _cgo0 := /*line :1116:28*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1116:39*/_Cfunc_setFloatingWindowLevel(_cgo0); }()
	case MacWindowLevelTornOffMenu:
		func() { _cgo0 := /*line :1118:31*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1118:42*/_Cfunc_setTornOffMenuWindowLevel(_cgo0); }()
	case MacWindowLevelModalPanel:
		func() { _cgo0 := /*line :1120:30*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1120:41*/_Cfunc_setModalPanelWindowLevel(_cgo0); }()
	case MacWindowLevelMainMenu:
		func() { _cgo0 := /*line :1122:28*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1122:39*/_Cfunc_setMainMenuWindowLevel(_cgo0); }()
	case MacWindowLevelStatus:
		func() { _cgo0 := /*line :1124:26*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1124:37*/_Cfunc_setStatusWindowLevel(_cgo0); }()
	case MacWindowLevelPopUpMenu:
		func() { _cgo0 := /*line :1126:29*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1126:40*/_Cfunc_setPopUpMenuWindowLevel(_cgo0); }()
	case MacWindowLevelScreenSaver:
		func() { _cgo0 := /*line :1128:31*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1128:42*/_Cfunc_setScreenSaverWindowLevel(_cgo0); }()
	}
}

func (w *macosWebviewWindow) width() int {
	var width  /*line :1133:12*/_Ctype_int /*line :1133:17*/
	var wg sync.WaitGroup
	wg.Add(1)
	globalApplication.dispatchOnMainThread(func() {
		width = func() _Ctype_int{ _cgo0 := /*line :1137:28*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); return /*line :1137:39*/_Cfunc_windowGetWidth(_cgo0); }()
		wg.Done()
	})
	wg.Wait()
	return int(width)
}
func (w *macosWebviewWindow) height() int {
	var height  /*line :1144:13*/_Ctype_int /*line :1144:18*/
	var wg sync.WaitGroup
	wg.Add(1)
	globalApplication.dispatchOnMainThread(func() {
		height = func() _Ctype_int{ _cgo0 := /*line :1148:30*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); return /*line :1148:41*/_Cfunc_windowGetHeight(_cgo0); }()
		wg.Done()
	})
	wg.Wait()
	return int(height)
}

func bool2CboolPtr(value bool) * /*line :1155:33*/_Ctype_bool /*line :1155:39*/ {
	v :=  /*line :1156:7*/_Ctype_bool /*line :1156:13*/(value)
	return &v
}

func (w *macosWebviewWindow) getWebviewPreferences()  /*line :1160:54*/_Ctype_struct_WebviewPreferences /*line :1160:81*/ {
	wvprefs := w.parent.options.Mac.WebviewPreferences

	var result  /*line :1163:13*/_Ctype_struct_WebviewPreferences /*line :1163:40*/

	if wvprefs.TextInteractionEnabled.IsSet() {
		result.TextInteractionEnabled = bool2CboolPtr(wvprefs.TextInteractionEnabled.Get())
	}
	if wvprefs.TabFocusesLinks.IsSet() {
		result.TabFocusesLinks = bool2CboolPtr(wvprefs.TabFocusesLinks.Get())
	}
	if wvprefs.FullscreenEnabled.IsSet() {
		result.FullscreenEnabled = bool2CboolPtr(wvprefs.FullscreenEnabled.Get())
	}

	return result
}

func (w *macosWebviewWindow) run() {
	for eventId := range w.parent.eventListeners {
		w.on(eventId)
	}
	globalApplication.dispatchOnMainThread(func() {
		options := w.parent.options
		macOptions := options.Mac

		w.nsWindow = ( /*line :1186:16*/_Cfunc_windowNew /*line :1186:26*/)( /*line :1186:28*/_Ctype_uint /*line :1186:34*/(w.parent.id),
			 /*line :1187:4*/_Ctype_int /*line :1187:9*/(options.Width),
			 /*line :1188:4*/_Ctype_int /*line :1188:9*/(options.Height),
			 /*line :1189:4*/_Ctype_bool /*line :1189:10*/(macOptions.EnableFraudulentWebsiteWarnings),
			 /*line :1190:4*/_Ctype_bool /*line :1190:10*/(options.Frameless),
			 /*line :1191:4*/_Ctype_bool /*line :1191:10*/(options.EnableDragAndDrop),
			w.getWebviewPreferences(),
		)
		w.setTitle(options.Title)
		w.setResizable(!options.DisableResize)
		if options.MinWidth != 0 || options.MinHeight != 0 {
			w.setMinSize(options.MinWidth, options.MinHeight)
		}
		if options.MaxWidth != 0 || options.MaxHeight != 0 {
			w.setMaxSize(options.MaxWidth, options.MaxHeight)
		}
		//w.setZoom(options.Zoom)
		w.enableDevTools()

		w.setBackgroundColour(options.BackgroundColour)

		switch macOptions.Backdrop {
		case MacBackdropTransparent:
			func() { _cgo0 := /*line :1209:27*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1209:38*/_Cfunc_windowSetTransparent(_cgo0); }()
			func() { _cgo0 := /*line :1210:28*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1210:39*/_Cfunc_webviewSetTransparent(_cgo0); }()
		case MacBackdropTranslucent:
			func() { _cgo0 := /*line :1212:27*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1212:38*/_Cfunc_windowSetTranslucent(_cgo0); }()
			func() { _cgo0 := /*line :1213:28*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1213:39*/_Cfunc_webviewSetTransparent(_cgo0); }()
		case MacBackdropNormal:
		}

		if macOptions.WindowLevel == "" {
			macOptions.WindowLevel = MacWindowLevelNormal
		}
		w.setWindowLevel(macOptions.WindowLevel)

		// Initialise the window buttons
		w.setMinimiseButtonState(options.MinimiseButtonState)
		w.setMaximiseButtonState(options.MaximiseButtonState)
		w.setCloseButtonState(options.CloseButtonState)

		// Ignore mouse events if requested
		w.setIgnoreMouseEvents(options.IgnoreMouseEvents)

		titleBarOptions := macOptions.TitleBar
		if !w.parent.options.Frameless {
			func() { _cgo0 := /*line :1232:42*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :1232:60*/(titleBarOptions.AppearsTransparent); _cgoCheckPointer(_cgo0, nil); /*line :1232:97*/_Cfunc_windowSetTitleBarAppearsTransparent(_cgo0, _cgo1); }()
			func() { _cgo0 := /*line :1233:28*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :1233:46*/(titleBarOptions.Hide); _cgoCheckPointer(_cgo0, nil); /*line :1233:69*/_Cfunc_windowSetHideTitleBar(_cgo0, _cgo1); }()
			func() { _cgo0 := /*line :1234:25*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :1234:43*/(titleBarOptions.HideTitle); _cgoCheckPointer(_cgo0, nil); /*line :1234:71*/_Cfunc_windowSetHideTitle(_cgo0, _cgo1); }()
			func() { _cgo0 := /*line :1235:31*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :1235:49*/(titleBarOptions.FullSizeContent); _cgoCheckPointer(_cgo0, nil); /*line :1235:83*/_Cfunc_windowSetFullSizeContent(_cgo0, _cgo1); }()
			func() { _cgo0 := /*line :1236:26*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :1236:44*/(titleBarOptions.UseToolbar); _cgoCheckPointer(_cgo0, nil); /*line :1236:73*/_Cfunc_windowSetUseToolbar(_cgo0, _cgo1); }()
			func() { _cgo0 := /*line :1237:28*/w.nsWindow; var _cgo1 _Ctype_int = _Ctype_int /*line :1237:45*/(titleBarOptions.ToolbarStyle); _cgoCheckPointer(_cgo0, nil); /*line :1237:76*/_Cfunc_windowSetToolbarStyle(_cgo0, _cgo1); }()
			func() { _cgo0 := /*line :1238:41*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :1238:59*/(titleBarOptions.ShowToolbarWhenFullscreen); _cgoCheckPointer(_cgo0, nil); /*line :1238:103*/_Cfunc_windowSetShowToolbarWhenFullscreen(_cgo0, _cgo1); }()
			func() { _cgo0 := /*line :1239:36*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :1239:54*/(titleBarOptions.HideToolbarSeparator); _cgoCheckPointer(_cgo0, nil); /*line :1239:93*/_Cfunc_windowSetHideToolbarSeparator(_cgo0, _cgo1); }()
		}

		if macOptions.Appearance != "" {
			func() { _cgo0 := /*line :1243:36*/w.nsWindow; var _cgo1 *_Ctype_char = _Cfunc_CString /*line :1243:57*/(string(macOptions.Appearance)); _cgoCheckPointer(_cgo0, nil); /*line :1243:89*/_Cfunc_windowSetAppearanceTypeByName(_cgo0, _cgo1); }()
		}

		if macOptions.InvisibleTitleBarHeight != 0 {
			func() { _cgo0 := /*line :1247:33*/w.nsWindow; var _cgo1 _Ctype_uint = _Ctype_uint /*line :1247:51*/(macOptions.InvisibleTitleBarHeight); _cgoCheckPointer(_cgo0, nil); /*line :1247:88*/_Cfunc_windowSetInvisibleTitleBar(_cgo0, _cgo1); }()
		}

		switch w.parent.options.StartState {
		case WindowStateMaximised:
			w.maximise()
		case WindowStateMinimised:
			w.minimise()
		case WindowStateFullscreen:
			w.fullscreen()
		case WindowStateNormal:
		}
		if w.parent.options.InitialPosition == WindowCentered {
			func() { _cgo0 := /*line :1260:19*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1260:30*/_Cfunc_windowCenter(_cgo0); }()
		} else {
			w.setPosition(options.X, options.Y)
		}

		startURL, err := assetserver.GetStartURL(options.URL)
		if err != nil {
			globalApplication.fatal(err.Error())
		}

		w.setURL(startURL)

		// We need to wait for the HTML to load before we can execute the javascript
		w.parent.OnWindowEvent(events.Mac.WebViewDidFinishNavigation, func(_ *WindowEvent) {
			InvokeAsync(func() {
				if options.JS != "" {
					w.execJS(options.JS)
				}
				if options.CSS != "" {
					func() { _cgo0 := /*line :1279:24*/w.nsWindow; var _cgo1 *_Ctype_char = _Cfunc_CString /*line :1279:45*/(options.CSS); _cgoCheckPointer(_cgo0, nil); /*line :1279:59*/_Cfunc_windowInjectCSS(_cgo0, _cgo1); }()
				}
				if !options.Hidden {
					w.parent.Show()
					w.setHasShadow(!options.Mac.DisableShadow)
					w.setAlwaysOnTop(options.AlwaysOnTop)
				} else {
					// We have to wait until the window is shown before we can remove the shadow
					var cancel func()
					cancel = w.parent.OnWindowEvent(events.Mac.WindowDidBecomeKey, func(_ *WindowEvent) {
						InvokeAsync(func() {
							if !w.isVisible() {
								w.parent.Show()
							}
							w.setHasShadow(!options.Mac.DisableShadow)
							w.setAlwaysOnTop(options.AlwaysOnTop)
							cancel()
						})
					})
				}
			})
		})

		// Translate ShouldClose to common WindowClosing event
		w.parent.OnWindowEvent(events.Mac.WindowShouldClose, func(_ *WindowEvent) {
			w.parent.emit(events.Common.WindowClosing)
		})

		// Translate WindowDidResignKey to common WindowLostFocus event
		w.parent.OnWindowEvent(events.Mac.WindowDidResignKey, func(_ *WindowEvent) {
			w.parent.emit(events.Common.WindowLostFocus)
		})
		w.parent.OnWindowEvent(events.Mac.WindowDidResignMain, func(_ *WindowEvent) {
			w.parent.emit(events.Common.WindowLostFocus)
		})
		w.parent.OnWindowEvent(events.Mac.WindowDidResize, func(_ *WindowEvent) {
			w.parent.emit(events.Common.WindowDidResize)
		})

		if options.HTML != "" {
			w.setHTML(options.HTML)
		}

	})
}

func (w *macosWebviewWindow) nativeWindowHandle() uintptr {
	return uintptr(w.nsWindow)
}

func (w *macosWebviewWindow) setBackgroundColour(colour RGBA) {

	func() { _cgo0 := /*line :1331:30*/w.nsWindow; var _cgo1 _Ctype_int = _Ctype_int /*line :1331:47*/(colour.Red); var _cgo2 _Ctype_int = _Ctype_int /*line :1331:66*/(colour.Green); var _cgo3 _Ctype_int = _Ctype_int /*line :1331:87*/(colour.Blue); var _cgo4 _Ctype_int = _Ctype_int /*line :1331:107*/(colour.Alpha); _cgoCheckPointer(_cgo0, nil); /*line :1331:122*/_Cfunc_windowSetBackgroundColour(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
}

func (w *macosWebviewWindow) relativePosition() (int, int) {
	var x, y  /*line :1335:11*/_Ctype_int /*line :1335:16*/
	InvokeSync(func() {
		func() { _cgo0 := /*line :1337:31*/w.nsWindow; var _cgo1 *_Ctype_int = /*line :1337:43*/&x; var _cgo2 *_Ctype_int = /*line :1337:47*/&y; _cgoCheckPointer(_cgo0, nil); /*line :1337:50*/_Cfunc_windowGetRelativePosition(_cgo0, _cgo1, _cgo2); }()
	})

	return int(x), int(y)
}

func (w *macosWebviewWindow) position() (int, int) {
	var x, y  /*line :1344:11*/_Ctype_int /*line :1344:16*/
	InvokeSync(func() {
		func() { _cgo0 := /*line :1346:23*/w.nsWindow; var _cgo1 *_Ctype_int = /*line :1346:35*/&x; var _cgo2 *_Ctype_int = /*line :1346:39*/&y; _cgoCheckPointer(_cgo0, nil); /*line :1346:42*/_Cfunc_windowGetPosition(_cgo0, _cgo1, _cgo2); }()
	})

	return int(x), int(y)
}

func (w *macosWebviewWindow) bounds() Rect {
	// DOTO: do it in a single step + proper DPI scaling
	var x, y, width, height  /*line :1354:26*/_Ctype_int /*line :1354:31*/
	InvokeSync(func() {
		func() { _cgo0 := /*line :1356:23*/w.nsWindow; var _cgo1 *_Ctype_int = /*line :1356:35*/&x; var _cgo2 *_Ctype_int = /*line :1356:39*/&y; _cgoCheckPointer(_cgo0, nil); /*line :1356:42*/_Cfunc_windowGetPosition(_cgo0, _cgo1, _cgo2); }()
		func() { _cgo0 := /*line :1357:19*/w.nsWindow; var _cgo1 *_Ctype_int = /*line :1357:31*/&width; var _cgo2 *_Ctype_int = /*line :1357:39*/&height; _cgoCheckPointer(_cgo0, nil); /*line :1357:47*/_Cfunc_windowGetSize(_cgo0, _cgo1, _cgo2); }()
	})

	return Rect{
		X:      int(x),
		Y:      int(y),
		Width:  int(width),
		Height: int(height),
	}
}

func (w *macosWebviewWindow) setBounds(bounds Rect) {
	// DOTO: do it in a single step + proper DPI scaling
	func() { _cgo0 := /*line :1370:22*/w.nsWindow; var _cgo1 _Ctype_int = _Ctype_int /*line :1370:39*/(bounds.X); var _cgo2 _Ctype_int = _Ctype_int /*line :1370:56*/(bounds.Y); _cgoCheckPointer(_cgo0, nil); /*line :1370:67*/_Cfunc_windowSetPosition(_cgo0, _cgo1, _cgo2); }()
	func() { _cgo0 := /*line :1371:18*/w.nsWindow; var _cgo1 _Ctype_int = _Ctype_int /*line :1371:35*/(bounds.Width); var _cgo2 _Ctype_int = _Ctype_int /*line :1371:56*/(bounds.Height); _cgoCheckPointer(_cgo0, nil); /*line :1371:72*/_Cfunc_windowSetSize(_cgo0, _cgo1, _cgo2); }()
}

func (w *macosWebviewWindow) physicalBounds() Rect {
	// TODO: proper DPI scaling
	return w.bounds()
}

func (w *macosWebviewWindow) setPhysicalBounds(physicalBounds Rect) {
	// TODO: proper DPI scaling
	w.setBounds(physicalBounds)
}

func (w *macosWebviewWindow) destroy() {
	w.parent.markAsDestroyed()
	func() { _cgo0 := /*line :1386:18*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1386:29*/_Cfunc_windowDestroy(_cgo0); }()
}

func (w *macosWebviewWindow) setHTML(html string) {
	// Convert HTML to C string
	cHTML := ( /*line :1391:11*/_Cfunc_CString /*line :1391:19*/)(html)
	// Render HTML
	func() { _cgo0 := /*line :1393:21*/w.nsWindow; var _cgo1 *_Ctype_char = /*line :1393:33*/cHTML; _cgoCheckPointer(_cgo0, nil); /*line :1393:39*/_Cfunc_windowRenderHTML(_cgo0, _cgo1); }()
}

func (w *macosWebviewWindow) startDrag() error {
	func() { _cgo0 := /*line :1397:14*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); /*line :1397:25*/_Cfunc_startDrag(_cgo0); }()
	return nil
}

func (w *macosWebviewWindow) setMinimiseButtonState(state ButtonState) {
	func() { _cgo0 := /*line :1402:27*/w.nsWindow; var _cgo1 _Ctype_int = _Ctype_int /*line :1402:44*/(state); _cgoCheckPointer(_cgo0, nil); /*line :1402:52*/_Cfunc_setMinimiseButtonState(_cgo0, _cgo1); }()
}

func (w *macosWebviewWindow) setMaximiseButtonState(state ButtonState) {
	func() { _cgo0 := /*line :1406:27*/w.nsWindow; var _cgo1 _Ctype_int = _Ctype_int /*line :1406:44*/(state); _cgoCheckPointer(_cgo0, nil); /*line :1406:52*/_Cfunc_setMaximiseButtonState(_cgo0, _cgo1); }()
}

func (w *macosWebviewWindow) setCloseButtonState(state ButtonState) {
	func() { _cgo0 := /*line :1410:24*/w.nsWindow; var _cgo1 _Ctype_int = _Ctype_int /*line :1410:41*/(state); _cgoCheckPointer(_cgo0, nil); /*line :1410:49*/_Cfunc_setCloseButtonState(_cgo0, _cgo1); }()
}

func (w *macosWebviewWindow) isIgnoreMouseEvents() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :1414:36*/w.nsWindow; _cgoCheckPointer(_cgo0, nil); return /*line :1414:47*/_Cfunc_isIgnoreMouseEvents(_cgo0); }())
}

func (w *macosWebviewWindow) setIgnoreMouseEvents(ignore bool) {
	func() { _cgo0 := /*line :1418:25*/w.nsWindow; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :1418:43*/(ignore); _cgoCheckPointer(_cgo0, nil); /*line :1418:52*/_Cfunc_setIgnoreMouseEvents(_cgo0, _cgo1); }()
}

func (w *macosWebviewWindow) cut() {
}

func (w *macosWebviewWindow) paste() {
}

func (w *macosWebviewWindow) copy() {
}

func (w *macosWebviewWindow) selectAll() {
}

func (w *macosWebviewWindow) undo() {
}

func (w *macosWebviewWindow) delete() {
}

func (w *macosWebviewWindow) redo() {
}
