// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/jamesonzeller/go/pkg/mod/github.com/wailsapp/wails/v3@v3.0.0-alpha.9/pkg/application/dialogs_darwin.go:1:1
//go:build darwin

package application; import _cgo_unsafe "unsafe"

/*
#cgo CFLAGS: -mmacosx-version-min=10.13 -x objective-c
#cgo LDFLAGS: -framework Cocoa -mmacosx-version-min=10.13 -framework UniformTypeIdentifiers

#import <Cocoa/Cocoa.h>

#import <UniformTypeIdentifiers/UTType.h>
#import "dialogs_darwin_delegate.h"

extern void openFileDialogCallback(uint id, char* path);
extern void openFileDialogCallbackEnd(uint id);
extern void saveFileDialogCallback(uint id, char* path);
extern void dialogCallback(int id, int buttonPressed);

static void showAboutBox(char* title, char *message, void *icon, int length) {

	// run on main thread
	NSAlert *alert = [[NSAlert alloc] init];
	if (title != NULL) {
		[alert setMessageText:[NSString stringWithUTF8String:title]];
		free(title);
	}
	if (message != NULL) {
		[alert setInformativeText:[NSString stringWithUTF8String:message]];
		free(message);
	}
	if (icon != NULL) {
		NSImage *image = [[NSImage alloc] initWithData:[NSData dataWithBytes:icon length:length]];
		[alert setIcon:image];
	}
	[alert setAlertStyle:NSAlertStyleInformational];
	[alert runModal];
}


// Create an NSAlert
static void* createAlert(int alertType, char* title, char *message, void *icon, int length) {
	NSAlert *alert = [[NSAlert alloc] init];
	[alert setAlertStyle:alertType];
	if (title != NULL) {
		[alert setMessageText:[NSString stringWithUTF8String:title]];
		free(title);
	}
	if (message != NULL) {
		[alert setInformativeText:[NSString stringWithUTF8String:message]];
		free(message);
	}
	if (icon != NULL) {
		NSImage *image = [[NSImage alloc] initWithData:[NSData dataWithBytes:icon length:length]];
		[alert setIcon:image];
	} else {
		if(alertType == NSAlertStyleCritical || alertType == NSAlertStyleWarning) {
			NSImage *image = [NSImage imageNamed:NSImageNameCaution];
			[alert setIcon:image];
		} else {
			NSImage *image = [NSImage imageNamed:NSImageNameInfo];
			[alert setIcon:image];
		}
	}
	return alert;

}

static int getButtonNumber(NSModalResponse response) {
	int buttonNumber = 0;
	if( response == NSAlertFirstButtonReturn ) {
		buttonNumber = 0;
	}
	else if( response == NSAlertSecondButtonReturn ) {
		buttonNumber = 1;
	}
	else if( response == NSAlertThirdButtonReturn ) {
		buttonNumber = 2;
	} else {
		buttonNumber = 3;
	}
	return buttonNumber;
}

// Run the dialog
static void dialogRunModal(void *dialog, void *parent, int callBackID) {
	NSAlert *alert = (__bridge NSAlert *)dialog;

	// If the parent is NULL, we are running a modal dialog, otherwise attach the alert to the parent
	if( parent == NULL ) {
		NSModalResponse response = [alert runModal];
		int returnCode = getButtonNumber(response);
		dialogCallback(callBackID, returnCode);
	} else {
		NSWindow *window = (__bridge NSWindow *)parent;
		[alert beginSheetModalForWindow:window completionHandler:^(NSModalResponse response) {
			int returnCode = getButtonNumber(response);
			dialogCallback(callBackID, returnCode);
		}];
	}
}

// Release the dialog
static void releaseDialog(void *dialog) {
	NSAlert *alert = (__bridge NSAlert *)dialog;
	[alert release];
}

// Add a button to the dialog
static void alertAddButton(void *dialog, char *label, bool isDefault, bool isCancel) {
	NSAlert *alert = (__bridge NSAlert *)dialog;
	NSButton *button = [alert addButtonWithTitle:[NSString stringWithUTF8String:label]];
	free(label);
    if( isDefault ) {
        [button setKeyEquivalent:@"\r"];
    } else if( isCancel ) {
        [button setKeyEquivalent:@"\033"];
    } else {
        [button setKeyEquivalent:@""];
    }
}

static void processOpenFileDialogResults(NSOpenPanel *panel, NSInteger result, uint dialogID) {
	const char *path = NULL;
	if (result == NSModalResponseOK) {
		NSArray *urls = [panel URLs];
		if ([urls count] > 0) {
			NSArray *urls = [panel URLs];
			for (NSURL *url in urls) {
				path = [[url path] UTF8String];
				openFileDialogCallback(dialogID, (char *)path);
			}
		} else {
			NSURL *url = [panel URL];
			path = [[url path] UTF8String];
			openFileDialogCallback(dialogID, (char *)path);
		}
	}
	openFileDialogCallbackEnd(dialogID);
}


static void showOpenFileDialog(unsigned int dialogID,
	bool canChooseFiles,
	bool canChooseDirectories,
	bool canCreateDirectories,
	bool showHiddenFiles,
	bool allowsMultipleSelection,
	bool resolvesAliases,
	bool hideExtension,
	bool treatsFilePackagesAsDirectories,
	bool allowsOtherFileTypes,
	char *filterPatterns,
	unsigned int filterPatternsCount,
	char* message,
	char* directory,
	char* buttonText,

	void *window) {

	// run on main thread
	NSOpenPanel *panel = [NSOpenPanel openPanel];

	// print out filterPatterns if length > 0
	if (filterPatternsCount > 0) {
		OpenPanelDelegate *delegate = [[OpenPanelDelegate alloc] init];
		[panel setDelegate:delegate];
		// Initialise NSString with bytes and UTF8 encoding
		NSString *filterPatternsString = [[NSString alloc] initWithBytes:filterPatterns length:filterPatternsCount encoding:NSUTF8StringEncoding];
		// Convert NSString to NSArray
		delegate.allowedExtensions = [filterPatternsString componentsSeparatedByString:@";"];

			// Use UTType if macOS 11 or higher to add file filters
#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
		if (@available(macOS 11, *)) {
			NSMutableArray *filterTypes = [NSMutableArray array];
			// Iterate the filtertypes, create uti's that are limited to the file extensions then add
			for (NSString *filterType in delegate.allowedExtensions) {
				[filterTypes addObject:[UTType typeWithFilenameExtension:filterType]];
			}
			[panel setAllowedContentTypes:filterTypes];
		}
#else
		[panel setAllowedFileTypes:delegate.allowedExtensions];
#endif

		// Free the memory
		free(filterPatterns);
	}


	if (message != NULL) {
		[panel setMessage:[NSString stringWithUTF8String:message]];
		free(message);
	}

	if (directory != NULL) {
		[panel setDirectoryURL:[NSURL fileURLWithPath:[NSString stringWithUTF8String:directory]]];
		free(directory);
	}

	if (buttonText != NULL) {
		[panel setPrompt:[NSString stringWithUTF8String:buttonText]];
		free(buttonText);
	}

	[panel setCanChooseFiles:canChooseFiles];
	[panel setCanChooseDirectories:canChooseDirectories];
	[panel setCanCreateDirectories:canCreateDirectories];
	[panel setShowsHiddenFiles:showHiddenFiles];
	[panel setAllowsMultipleSelection:allowsMultipleSelection];
	[panel setResolvesAliases:resolvesAliases];
	[panel setExtensionHidden:hideExtension];
	[panel setTreatsFilePackagesAsDirectories:treatsFilePackagesAsDirectories];
	[panel setAllowsOtherFileTypes:allowsOtherFileTypes];



	if (window != NULL) {
		[panel beginSheetModalForWindow:(__bridge NSWindow *)window completionHandler:^(NSInteger result) {
			processOpenFileDialogResults(panel, result, dialogID);
		}];
	} else {
		[panel beginWithCompletionHandler:^(NSInteger result) {
			processOpenFileDialogResults(panel, result, dialogID);
		}];
	}
}

static void showSaveFileDialog(unsigned int dialogID,
	bool canCreateDirectories,
	bool showHiddenFiles,
	bool canSelectHiddenExtension,
	bool hideExtension,
	bool treatsFilePackagesAsDirectories,
	bool allowOtherFileTypes,
	char* message,
	char* directory,
	char* buttonText,
	char* filename,
	void *window) {

	NSSavePanel *panel = [NSSavePanel savePanel];

	if (message != NULL) {
		[panel setMessage:[NSString stringWithUTF8String:message]];
		free(message);
	}

	if (directory != NULL) {
		[panel setDirectoryURL:[NSURL fileURLWithPath:[NSString stringWithUTF8String:directory]]];
		free(directory);
	}

	if (filename != NULL) {
		[panel setNameFieldStringValue:[NSString stringWithUTF8String:filename]];
		free(filename);
	}

	if (buttonText != NULL) {
		[panel setPrompt:[NSString stringWithUTF8String:buttonText]];
		free(buttonText);
	}

	[panel setCanCreateDirectories:canCreateDirectories];
	[panel setShowsHiddenFiles:showHiddenFiles];
	[panel setCanSelectHiddenExtension:canSelectHiddenExtension];
	[panel setExtensionHidden:hideExtension];
	[panel setTreatsFilePackagesAsDirectories:treatsFilePackagesAsDirectories];
	[panel setAllowsOtherFileTypes:allowOtherFileTypes];

	if (window != NULL) {
		[panel beginSheetModalForWindow:(__bridge NSWindow *)window completionHandler:^(NSInteger result) {
			const char *path = NULL;
			if (result == NSModalResponseOK) {
				NSURL *url = [panel URL];
				path = [[url path] UTF8String];
			}
			saveFileDialogCallback(dialogID, (char *)path);
		}];
	} else {
		[panel beginWithCompletionHandler:^(NSInteger result) {
			const char *path = NULL;
			if (result == NSModalResponseOK) {
				NSURL *url = [panel URL];
				path = [[url path] UTF8String];
			}
			saveFileDialogCallback(dialogID, (char *)path);
		}];
	}
}

*/
import _ "unsafe"
import (
	"strings"
	"sync"
	"unsafe"
)

const NSAlertStyleWarning =  /*line :300:29*/_Ctype_int /*line :300:34*/(0)
const NSAlertStyleInformational =  /*line :301:35*/_Ctype_int /*line :301:40*/(1)
const NSAlertStyleCritical =  /*line :302:30*/_Ctype_int /*line :302:35*/(2)

var alertTypeMap = map[DialogType] /*line :304:35*/_Ctype_int /*line :304:40*/{
	WarningDialogType:  NSAlertStyleWarning,
	InfoDialogType:     NSAlertStyleInformational,
	ErrorDialogType:    NSAlertStyleCritical,
	QuestionDialogType: NSAlertStyleInformational,
}

type dialogResultCallback func(int)

var (
	callbacks = make(map[int]dialogResultCallback)
	mutex     = &sync.Mutex{}
)

func addDialogCallback(callback dialogResultCallback) int {
	mutex.Lock()
	defer mutex.Unlock()

	// Find the first free integer key
	var id int
	for {
		if _, exists := callbacks[id]; !exists {
			break
		}
		id++
	}

	// Save the function in the map using the integer key
	callbacks[id] = callback

	// Return the key
	return id
}

func removeDialogCallback(id int) {
	mutex.Lock()
	defer mutex.Unlock()
	delete(callbacks, id)
}

//export dialogCallback
func dialogCallback(id  /*line :345:24*/_Ctype_int /*line :345:29*/, buttonPressed  /*line :345:45*/_Ctype_int /*line :345:50*/) {
	mutex.Lock()
	callback, exists := callbacks[int(id)]
	mutex.Unlock()

	if !exists {
		return
	}

	// Call the function with the button number
	callback(int(buttonPressed)) // Replace nil with the actual slice of buttons
}

func (m *macosApp) showAboutDialog(title string, message string, icon []byte) {
	var iconData unsafe.Pointer
	if icon != nil {
		iconData = unsafe.Pointer(&icon[0])
	}
	InvokeAsync(func() {
		func() { var _cgo0 *_Ctype_char = _Cfunc_CString /*line :364:27*/(title); var _cgo1 *_Ctype_char = _Cfunc_CString /*line :364:45*/(message); _cgo2 := /*line :364:56*/iconData; var _cgo3 _Ctype_int = _Ctype_int /*line :364:71*/(len(icon)); _cgoCheckPointer(_cgo2, nil); /*line :364:83*/_Cfunc_showAboutBox(_cgo0, _cgo1, _cgo2, _cgo3); }()
	})
}

type macosDialog struct {
	dialog *MessageDialog

	nsDialog unsafe.Pointer
}

func (m *macosDialog) show() {
	InvokeAsync(func() {

		// Mac can only have 4 Buttons on a dialog
		if len(m.dialog.Buttons) > 4 {
			m.dialog.Buttons = m.dialog.Buttons[:4]
		}

		if m.nsDialog != nil {
			func() { _cgo0 := /*line :383:20*/m.nsDialog; _cgoCheckPointer(_cgo0, nil); /*line :383:31*/_Cfunc_releaseDialog(_cgo0); }()
		}
		var title * /*line :385:14*/_Ctype_char /*line :385:20*/
		if m.dialog.Title != "" {
			title = ( /*line :387:12*/_Cfunc_CString /*line :387:20*/)(m.dialog.Title)
		}
		var message * /*line :389:16*/_Ctype_char /*line :389:22*/
		if m.dialog.Message != "" {
			message = ( /*line :391:14*/_Cfunc_CString /*line :391:22*/)(m.dialog.Message)
		}
		var iconData unsafe.Pointer
		var iconLength  /*line :394:18*/_Ctype_int /*line :394:23*/
		if m.dialog.Icon != nil {
			iconData = unsafe.Pointer(&m.dialog.Icon[0])
			iconLength =  /*line :397:17*/_Ctype_int /*line :397:22*/(len(m.dialog.Icon))
		} else {
			// if it's an error, use the application Icon
			if m.dialog.DialogType == ErrorDialogType {
				if globalApplication.options.Icon != nil {
					iconData = unsafe.Pointer(&globalApplication.options.Icon[0])
					iconLength =  /*line :403:19*/_Ctype_int /*line :403:24*/(len(globalApplication.options.Icon))
				}
			}
		}
		var parent unsafe.Pointer
		if m.dialog.window != nil {
			// get NSWindow from window
			window, _ := m.dialog.window.NativeWindowHandle()
			parent = unsafe.Pointer(window)
		}

		alertType, ok := alertTypeMap[m.dialog.DialogType]
		if !ok {
			alertType = ( /*line :416:16*/_Ciconst_NSAlertStyleInformational /*line :416:42*/)
		}

		m.nsDialog = func() _cgo_unsafe.Pointer{ var _cgo0 _Ctype_int = /*line :419:30*/alertType; var _cgo1 *_Ctype_char = /*line :419:41*/title; var _cgo2 *_Ctype_char = /*line :419:48*/message; _cgo3 := /*line :419:57*/iconData; var _cgo4 _Ctype_int = /*line :419:67*/iconLength; _cgoCheckPointer(_cgo3, nil); return /*line :419:78*/_Cfunc_createAlert(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()

		// Reverse the Buttons so that the default is on the right
		reversedButtons := make([]*Button, len(m.dialog.Buttons))
		var count = 0
		for i := len(m.dialog.Buttons) - 1; i >= 0; i-- {
			button := m.dialog.Buttons[i]
			func() { _cgo0 := /*line :426:21*/m.nsDialog; var _cgo1 *_Ctype_char = _Cfunc_CString /*line :426:42*/(button.Label); var _cgo2 _Ctype__Bool = _Ctype_bool /*line :426:64*/(button.IsDefault); var _cgo3 _Ctype__Bool = _Ctype_bool /*line :426:90*/(button.IsCancel); _cgoCheckPointer(_cgo0, nil); /*line :426:108*/_Cfunc_alertAddButton(_cgo0, _cgo1, _cgo2, _cgo3); }()
			reversedButtons[count] = m.dialog.Buttons[i]
			count++
		}

		var callBackID int
		callBackID = addDialogCallback(func(buttonPressed int) {
			if len(m.dialog.Buttons) > buttonPressed {
				button := reversedButtons[buttonPressed]
				if button.Callback != nil {
					button.Callback()
				}
			}
			removeDialogCallback(callBackID)
		})

		func() { _cgo0 := /*line :442:20*/m.nsDialog; _cgo1 := /*line :442:32*/parent; var _cgo2 _Ctype_int = _Ctype_int /*line :442:45*/(callBackID); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :442:58*/_Cfunc_dialogRunModal(_cgo0, _cgo1, _cgo2); }()

	})

}

func newDialogImpl(d *MessageDialog) *macosDialog {
	return &macosDialog{
		dialog: d,
	}
}

type macosOpenFileDialog struct {
	dialog *OpenFileDialogStruct
}

func newOpenFileDialogImpl(d *OpenFileDialogStruct) *macosOpenFileDialog {
	return &macosOpenFileDialog{
		dialog: d,
	}
}

func toCString(s string) * /*line :464:27*/_Ctype_char /*line :464:33*/ {
	if s == "" {
		return nil
	}
	return ( /*line :468:9*/_Cfunc_CString /*line :468:17*/)(s)
}

func (m *macosOpenFileDialog) show() (chan string, error) {
	openFileResponses[m.dialog.id] = make(chan string)
	nsWindow := unsafe.Pointer(nil)
	if m.dialog.window != nil {
		// get NSWindow from window
		window, _ := m.dialog.window.NativeWindowHandle()
		nsWindow = unsafe.Pointer(window)
	}

	// Massage filter patterns into macOS format
	// We iterate all filter patterns, tidy them up and then join them with a semicolon
	// This should produce a single string of extensions like "png;jpg;gif"
	var filterPatterns string
	if len(m.dialog.filters) > 0 {
		var allPatterns []string
		for _, filter := range m.dialog.filters {
			patternComponents := strings.Split(filter.Pattern, ";")
			for i, component := range patternComponents {
				filterPattern := strings.TrimSpace(component)
				filterPattern = strings.TrimPrefix(filterPattern, "*.")
				patternComponents[i] = filterPattern
			}
			allPatterns = append(allPatterns, strings.Join(patternComponents, ";"))
		}
		filterPatterns = strings.Join(allPatterns, ";")
	}
	func() { var _cgo0 _Ctype_uint = _Ctype_uint /*line :497:29*/(m.dialog.id); var _cgo1 _Ctype__Bool = _Ctype_bool /*line :498:9*/(m.dialog.canChooseFiles); var _cgo2 _Ctype__Bool = _Ctype_bool /*line :499:9*/(m.dialog.canChooseDirectories); var _cgo3 _Ctype__Bool = _Ctype_bool /*line :500:9*/(m.dialog.canCreateDirectories); var _cgo4 _Ctype__Bool = _Ctype_bool /*line :501:9*/(m.dialog.showHiddenFiles); var _cgo5 _Ctype__Bool = _Ctype_bool /*line :502:9*/(m.dialog.allowsMultipleSelection); var _cgo6 _Ctype__Bool = _Ctype_bool /*line :503:9*/(m.dialog.resolvesAliases); var _cgo7 _Ctype__Bool = _Ctype_bool /*line :504:9*/(m.dialog.hideExtension); var _cgo8 _Ctype__Bool = _Ctype_bool /*line :505:9*/(m.dialog.treatsFilePackagesAsDirectories); var _cgo9 _Ctype__Bool = _Ctype_bool /*line :506:9*/(m.dialog.allowsOtherFileTypes); var _cgo10 *_Ctype_char = /*line :507:3*/toCString(filterPatterns); var _cgo11 _Ctype_uint = _Ctype_uint /*line :508:9*/(len(filterPatterns)); var _cgo12 *_Ctype_char = /*line :509:3*/toCString(m.dialog.message); var _cgo13 *_Ctype_char = /*line :510:3*/toCString(m.dialog.directory); var _cgo14 *_Ctype_char = /*line :511:3*/toCString(m.dialog.buttonText); _cgo15 := /*line :512:3*/nsWindow; _cgoCheckPointer(_cgo15, nil); /*line :512:12*/_Cfunc_showOpenFileDialog(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7, _cgo8, _cgo9, _cgo10, _cgo11, _cgo12, _cgo13, _cgo14, _cgo15); }()

	return openFileResponses[m.dialog.id], nil
}

//export openFileDialogCallback
func openFileDialogCallback(cid  /*line :518:33*/_Ctype_uint /*line :518:39*/, cpath * /*line :518:48*/_Ctype_char /*line :518:54*/) {
	path := ( /*line :519:10*/_Cfunc_GoString /*line :519:19*/)(cpath)
	id := uint(cid)
	channel, ok := openFileResponses[id]
	if ok {
		channel <- path
	} else {
		panic("No channel found for open file dialog")
	}
}

//export openFileDialogCallbackEnd
func openFileDialogCallbackEnd(cid  /*line :530:36*/_Ctype_uint /*line :530:42*/) {
	id := uint(cid)
	channel, ok := openFileResponses[id]
	if ok {
		close(channel)
		delete(openFileResponses, id)
		freeDialogID(id)
	} else {
		panic("No channel found for open file dialog")
	}
}

type macosSaveFileDialog struct {
	dialog *SaveFileDialogStruct
}

func newSaveFileDialogImpl(d *SaveFileDialogStruct) *macosSaveFileDialog {
	return &macosSaveFileDialog{
		dialog: d,
	}
}

func (m *macosSaveFileDialog) show() (chan string, error) {
	saveFileResponses[m.dialog.id] = make(chan string)
	nsWindow := unsafe.Pointer(nil)
	if m.dialog.window != nil {
		// get NSWindow from window
		window, _ := m.dialog.window.NativeWindowHandle()
		nsWindow = unsafe.Pointer(window)
	}
	func() { var _cgo0 _Ctype_uint = _Ctype_uint /*line :560:29*/(m.dialog.id); var _cgo1 _Ctype__Bool = _Ctype_bool /*line :561:9*/(m.dialog.canCreateDirectories); var _cgo2 _Ctype__Bool = _Ctype_bool /*line :562:9*/(m.dialog.showHiddenFiles); var _cgo3 _Ctype__Bool = _Ctype_bool /*line :563:9*/(m.dialog.canSelectHiddenExtension); var _cgo4 _Ctype__Bool = _Ctype_bool /*line :564:9*/(m.dialog.hideExtension); var _cgo5 _Ctype__Bool = _Ctype_bool /*line :565:9*/(m.dialog.treatsFilePackagesAsDirectories); var _cgo6 _Ctype__Bool = _Ctype_bool /*line :566:9*/(m.dialog.allowOtherFileTypes); var _cgo7 *_Ctype_char = /*line :567:3*/toCString(m.dialog.message); var _cgo8 *_Ctype_char = /*line :568:3*/toCString(m.dialog.directory); var _cgo9 *_Ctype_char = /*line :569:3*/toCString(m.dialog.buttonText); var _cgo10 *_Ctype_char = /*line :570:3*/toCString(m.dialog.filename); _cgo11 := /*line :571:3*/nsWindow; _cgoCheckPointer(_cgo11, nil); /*line :571:12*/_Cfunc_showSaveFileDialog(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7, _cgo8, _cgo9, _cgo10, _cgo11); }()
	return saveFileResponses[m.dialog.id], nil
}

//export saveFileDialogCallback
func saveFileDialogCallback(cid  /*line :576:33*/_Ctype_uint /*line :576:39*/, cpath * /*line :576:48*/_Ctype_char /*line :576:54*/) {
	// Covert the path to a string
	path := ( /*line :578:10*/_Cfunc_GoString /*line :578:19*/)(cpath)
	id := uint(cid)
	// put response on channel
	channel, ok := saveFileResponses[id]
	if ok {
		channel <- path
		close(channel)
		delete(saveFileResponses, id)
		freeDialogID(id)

	} else {
		panic("No channel found for save file dialog")
	}
}
