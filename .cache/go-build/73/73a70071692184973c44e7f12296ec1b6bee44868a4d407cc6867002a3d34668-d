// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/jamesonzeller/go/pkg/mod/github.com/wailsapp/wails/v3@v3.0.0-alpha.9/pkg/application/systemtray_darwin.go:1:1
//go:build darwin

package application; import _cgo_unsafe "unsafe"

/*
#cgo CFLAGS: -mmacosx-version-min=10.13 -x objective-c
#cgo LDFLAGS: -framework Cocoa -framework WebKit

#include "Cocoa/Cocoa.h"
#include "menuitem_darwin.h"
#include "systemtray_darwin.h"
*/
import _ "unsafe"
import (
	"unsafe"

	"fmt"
	"github.com/leaanthony/go-ansi-parser"
)

type macosSystemTray struct {
	id    uint
	label string
	icon  []byte
	menu  *Menu

	nsStatusItem      unsafe.Pointer
	nsImage           unsafe.Pointer
	nsMenu            unsafe.Pointer
	iconPosition      int
	isTemplateIcon    bool
	parent            *SystemTray
	lastClickedScreen unsafe.Pointer
}

func (s *macosSystemTray) openMenu() {
	if s.nsMenu == nil {
		return
	}
	func() { _cgo0 := /*line :40:13*/s.nsStatusItem; _cgo1 := /*line :40:29*/s.nsMenu; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :40:38*/_Cfunc_showMenu(_cgo0, _cgo1); }()
}

type button int

const (
	leftButtonDown  button = 1
	rightButtonDown button = 3
)

// system tray map
var systemTrayMap = make(map[uint]*macosSystemTray)

//export systrayClickCallback
func systrayClickCallback(id  /*line :54:30*/_Ctype_long /*line :54:36*/, buttonID  /*line :54:47*/_Ctype_int /*line :54:52*/) {
	// Get the system tray
	systemTray := systemTrayMap[uint(id)]
	if systemTray == nil {
		globalApplication.error("system tray not found: %v", id)
		return
	}
	systemTray.processClick(button(buttonID))
}

func (s *macosSystemTray) setIconPosition(position int) {
	s.iconPosition = position
}

func (s *macosSystemTray) setMenu(menu *Menu) {
	s.menu = menu
}

func (s *macosSystemTray) positionWindow(window *WebviewWindow, offset int) error {
	// Get the window's native window
	impl := window.impl.(*macosWebviewWindow)

	// Position the window relative to the systray
	func() { _cgo0 := /*line :77:29*/s.nsStatusItem; _cgo1 := /*line :77:45*/impl.nsWindow; var _cgo2 _Ctype_int = _Ctype_int /*line :77:65*/(offset); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :77:74*/_Cfunc_systemTrayPositionWindow(_cgo0, _cgo1, _cgo2); }()

	return nil
}

func (s *macosSystemTray) getScreen() (*Screen, error) {
	if s.lastClickedScreen != nil {
		// Get the screen frame
		frame := func() _Ctype_struct_CGRect{ _cgo0 := /*line :85:29*/s.lastClickedScreen; _cgoCheckPointer(_cgo0, nil); return /*line :85:49*/_Cfunc_NSScreen_frame(_cgo0); }()
		result := &Screen{
			Bounds: Rect{
				X:      int(frame.origin.x),
				Y:      int(frame.origin.y),
				Width:  int(frame.size.width),
				Height: int(frame.size.height),
			},
		}
		return result, nil
	}
	return nil, fmt.Errorf("no screen available")
}

func (s *macosSystemTray) bounds() (*Rect, error) {
	var rect  /*line :100:11*/_Ctype_NSRect /*line :100:19*/
	var screen unsafe.Pointer
	func() { _cgo0 := /*line :102:24*/s.nsStatusItem; var _cgo1 *_Ctype_struct_CGRect = /*line :102:40*/&rect; _cgoBase2 := /*line :102:47*/&screen; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); /*line :102:55*/_Cfunc_systemTrayGetBounds(_cgo0, _cgo1, _cgo2); }()

	// Store the screen for use in positionWindow
	s.lastClickedScreen = screen

	// Return the screen-relative coordinates
	result := &Rect{
		X:      int(rect.origin.x),
		Y:      int(rect.origin.y),
		Width:  int(rect.size.width),
		Height: int(rect.size.height),
	}
	return result, nil
}

func (s *macosSystemTray) run() {
	globalApplication.dispatchOnMainThread(func() {
		if s.nsStatusItem != nil {
			Fatal("System tray '%d' already running", s.id)
		}
		s.nsStatusItem = unsafe.Pointer(( /*line :122:35*/_Cfunc_systemTrayNew /*line :122:49*/)( /*line :122:51*/_Ctype_long /*line :122:57*/(s.id)))

		if s.label != "" {
			s.setLabel(s.label)
		}
		if s.icon != nil {
			s.nsImage = unsafe.Pointer(( /*line :128:31*/_Cfunc_imageFromBytes /*line :128:46*/)((* /*line :128:50*/_Ctype_uchar /*line :128:57*/)(&s.icon[0]),  /*line :128:72*/_Ctype_int /*line :128:77*/(len(s.icon))))
			func() { _cgo0 := /*line :129:24*/s.nsStatusItem; _cgo1 := /*line :129:40*/s.nsImage; var _cgo2 _Ctype_int = _Ctype_int /*line :129:56*/(s.iconPosition); var _cgo3 _Ctype__Bool = _Ctype_bool /*line :129:80*/(s.isTemplateIcon); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :129:99*/_Cfunc_systemTraySetIcon(_cgo0, _cgo1, _cgo2, _cgo3); }()
		}
		if s.menu != nil {
			s.menu.Update()
			// Convert impl to macosMenu object
			s.nsMenu = (s.menu.impl).(*macosMenu).nsMenu
		}
	})
}

func (s *macosSystemTray) setIcon(icon []byte) {
	s.icon = icon
	globalApplication.dispatchOnMainThread(func() {
		s.nsImage = unsafe.Pointer(( /*line :142:30*/_Cfunc_imageFromBytes /*line :142:45*/)((* /*line :142:49*/_Ctype_uchar /*line :142:56*/)(&icon[0]),  /*line :142:69*/_Ctype_int /*line :142:74*/(len(icon))))
		func() { _cgo0 := /*line :143:23*/s.nsStatusItem; _cgo1 := /*line :143:39*/s.nsImage; var _cgo2 _Ctype_int = _Ctype_int /*line :143:55*/(s.iconPosition); var _cgo3 _Ctype__Bool = _Ctype_bool /*line :143:79*/(s.isTemplateIcon); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :143:98*/_Cfunc_systemTraySetIcon(_cgo0, _cgo1, _cgo2, _cgo3); }()
	})
}

func (s *macosSystemTray) setDarkModeIcon(icon []byte) {
	s.setIcon(icon)
}

func (s *macosSystemTray) setTemplateIcon(icon []byte) {
	s.icon = icon
	s.isTemplateIcon = true
	globalApplication.dispatchOnMainThread(func() {
		s.nsImage = unsafe.Pointer(( /*line :155:30*/_Cfunc_imageFromBytes /*line :155:45*/)((* /*line :155:49*/_Ctype_uchar /*line :155:56*/)(&icon[0]),  /*line :155:69*/_Ctype_int /*line :155:74*/(len(icon))))
		func() { _cgo0 := /*line :156:23*/s.nsStatusItem; _cgo1 := /*line :156:39*/s.nsImage; var _cgo2 _Ctype_int = _Ctype_int /*line :156:55*/(s.iconPosition); var _cgo3 _Ctype__Bool = _Ctype_bool /*line :156:79*/(s.isTemplateIcon); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :156:98*/_Cfunc_systemTraySetIcon(_cgo0, _cgo1, _cgo2, _cgo3); }()
	})
}

func newSystemTrayImpl(s *SystemTray) systemTrayImpl {
	result := &macosSystemTray{
		parent:         s,
		id:             s.id,
		label:          s.label,
		icon:           s.icon,
		menu:           s.menu,
		iconPosition:   s.iconPosition,
		isTemplateIcon: s.isTemplateIcon,
	}
	systemTrayMap[s.id] = result
	return result
}

func extractAnsiTextParts(text *ansi.StyledText) (label * /*line :174:58*/_Ctype_char /*line :174:64*/, fg * /*line :174:70*/_Ctype_char /*line :174:76*/, bg * /*line :174:82*/_Ctype_char /*line :174:88*/) {
	label = ( /*line :175:10*/_Cfunc_CString /*line :175:18*/)(text.Label)
	if text.FgCol != nil {
		fg = ( /*line :177:8*/_Cfunc_CString /*line :177:16*/)(text.FgCol.Hex)
	}
	if text.BgCol != nil {
		bg = ( /*line :180:8*/_Cfunc_CString /*line :180:16*/)(text.BgCol.Hex)
	}
	return
}

func (s *macosSystemTray) setLabel(label string) {
	s.label = label
	if !ansi.HasEscapeCodes(label) {
		func() { _cgo0 := /*line :188:24*/s.nsStatusItem; var _cgo1 *_Ctype_char = _Cfunc_CString /*line :188:49*/(label); _cgoCheckPointer(_cgo0, nil); /*line :188:57*/_Cfunc_systemTraySetLabel(_cgo0, _cgo1); }()
	} else {
		parsed, err := ansi.Parse(label)
		if err != nil {
			func() { _cgo0 := /*line :192:25*/s.nsStatusItem; var _cgo1 *_Ctype_char = _Cfunc_CString /*line :192:50*/(label); _cgoCheckPointer(_cgo0, nil); /*line :192:58*/_Cfunc_systemTraySetLabel(_cgo0, _cgo1); }()
			return
		}
		if len(parsed) == 0 {
			return
		}
		label, fg, bg := extractAnsiTextParts(parsed[0])
		var attributedString = ( /*line :199:26*/_Cfunc_createAttributedString /*line :199:49*/)(label, fg, bg)
		if len(parsed) > 1 {
			for _, parsedPart := range parsed[1:] {
				label, fg, bg = extractAnsiTextParts(parsedPart)
				attributedString = func() _cgo_unsafe.Pointer{ _cgo0 := /*line :203:49*/attributedString; var _cgo1 *_Ctype_char = /*line :203:67*/label; var _cgo2 *_Ctype_char = /*line :203:74*/fg; var _cgo3 *_Ctype_char = /*line :203:78*/bg; _cgoCheckPointer(_cgo0, nil); return /*line :203:81*/_Cfunc_appendAttributedString(_cgo0, _cgo1, _cgo2, _cgo3); }()
			}
		}

		func() { _cgo0 := /*line :207:28*/s.nsStatusItem; _cgo1 := /*line :207:44*/attributedString; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :207:61*/_Cfunc_systemTraySetANSILabel(_cgo0, _cgo1); }()
	}
}

func (s *macosSystemTray) destroy() {
	// Remove the status item from the status bar and its associated menu
	func() { _cgo0 := /*line :213:22*/s.nsStatusItem; _cgoCheckPointer(_cgo0, nil); /*line :213:37*/_Cfunc_systemTrayDestroy(_cgo0); }()
}

func (s *macosSystemTray) processClick(b button) {
	switch b {
	case leftButtonDown:
		// Check if we have a callback
		if s.parent.clickHandler != nil {
			s.parent.clickHandler()
			return
		}
		if s.parent.attachedWindow.Window != nil {
			s.parent.defaultClickHandler()
			return
		}
		if s.menu != nil {
			func() { _cgo0 := /*line :229:15*/s.nsStatusItem; _cgo1 := /*line :229:31*/s.nsMenu; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :229:40*/_Cfunc_showMenu(_cgo0, _cgo1); }()
		}
	case rightButtonDown:
		// Check if we have a callback
		if s.parent.rightClickHandler != nil {
			s.parent.rightClickHandler()
			return
		}
		if s.menu != nil {
			if s.parent.attachedWindow.Window != nil {
				s.parent.attachedWindow.Window.Hide()
			}
			func() { _cgo0 := /*line :241:15*/s.nsStatusItem; _cgo1 := /*line :241:31*/s.nsMenu; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :241:40*/_Cfunc_showMenu(_cgo0, _cgo1); }()
			return
		}
		if s.parent.attachedWindow.Window != nil {
			s.parent.defaultClickHandler()
		}
	}
}
