// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/jamesonzeller/go/pkg/mod/github.com/keybase/go-keychain@v0.0.1/corefoundation.go:1:1
//go:build darwin || ios
// +build darwin ios

package keychain

/*
#cgo LDFLAGS: -framework CoreFoundation

#include <CoreFoundation/CoreFoundation.h>

// Can't cast a *uintptr to *unsafe.Pointer in Go, and casting
// C.CFTypeRef to unsafe.Pointer is unsafe in Go, so have shim functions to
// do the casting in C (where it's safe).

// We add a suffix to the C functions below, because we copied this
// file from go-kext, which means that any project that depends on this
// package and go-kext would run into duplicate symbol errors otherwise.
//
// TODO: Move this file into its own package depended on by go-kext
// and this package.

CFDictionaryRef CFDictionaryCreateSafe2(CFAllocatorRef allocator, const uintptr_t *keys, const uintptr_t *values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks) {
  return CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, numValues, keyCallBacks, valueCallBacks);
}

CFArrayRef CFArrayCreateSafe2(CFAllocatorRef allocator, const uintptr_t *values, CFIndex numValues, const CFArrayCallBacks *callBacks) {
  return CFArrayCreate(allocator, (const void **)values, numValues, callBacks);
}
*/
import _ "unsafe"
import (
	"errors"
	"fmt"
	"math"
	"reflect"
	"unicode/utf8"
	"unsafe"
)

// Release releases memory pointed to by a CFTypeRef.
func Release(ref  /*line :41:18*/_Ctype_CFTypeRef /*line :41:29*/) {
	func() { var _cgo0 _Ctype_CFTypeRef = /*line :42:14*/ref; /*line :42:18*/_Cfunc_CFRelease(_cgo0); }()
}

// BytesToCFData will return a CFDataRef and if non-nil, must be released with
// Release(ref).
func BytesToCFData(b []byte) ( /*line :47:31*/_Ctype_CFDataRef /*line :47:42*/, error) {
	if uint64(len(b)) > math.MaxUint32 {
		return 0, errors.New("Data is too large")
	}
	var p * /*line :51:9*/_Ctype_UInt8 /*line :51:16*/
	if len(b) > 0 {
		p = (* /*line :53:9*/_Ctype_UInt8 /*line :53:16*/)(&b[0])
	}
	cfData := func() _Ctype_CFDataRef{ var _cgo0 _Ctype_CFAllocatorRef = /*line :55:27*/*_Cvar_kCFAllocatorDefault /*line :55:48*/; var _cgo1 *_Ctype_UInt8 = /*line :55:50*/p; var _cgo2 _Ctype_CFIndex = _Ctype_CFIndex /*line :55:62*/(len(b)); return /*line :55:71*/_Cfunc_CFDataCreate(_cgo0, _cgo1, _cgo2); }()
	if cfData == 0 {
		return 0, fmt.Errorf("CFDataCreate failed")
	}
	return cfData, nil
}

// CFDataToBytes converts CFData to bytes.
func CFDataToBytes(cfData  /*line :63:27*/_Ctype_CFDataRef /*line :63:38*/) ([]byte, error) {
	return func() []byte{ _cgo0 := /*line :64:19*/unsafe.Pointer(func() *_Ctype_UInt8{ var _cgo0 _Ctype_CFDataRef = /*line :64:53*/cfData; return /*line :64:60*/_Cfunc_CFDataGetBytePtr(_cgo0); }()); var _cgo1 _Ctype_int = _Ctype_int /*line :64:68*/(func() _Ctype_CFIndex{ var _cgo0 _Ctype_CFDataRef = /*line :64:87*/cfData; return /*line :64:94*/_Cfunc_CFDataGetLength(_cgo0); }()); _cgoCheckPointer(_cgo0, nil); return /*line :64:96*/_Cfunc_GoBytes(_cgo0, _cgo1); }(), nil
}

// MapToCFDictionary will return a CFDictionaryRef and if non-nil, must be
// released with Release(ref).
func MapToCFDictionary(m map[ /*line :69:30*/_Ctype_CFTypeRef /*line :69:41*/] /*line :69:42*/_Ctype_CFTypeRef /*line :69:53*/) ( /*line :69:56*/_Ctype_CFDictionaryRef /*line :69:73*/, error) {
	var keys, values [] /*line :70:21*/_Ctype_uintptr_t /*line :70:32*/
	for key, value := range m {
		keys = append(keys,  /*line :72:23*/_Ctype_uintptr_t /*line :72:34*/(key))
		values = append(values,  /*line :73:27*/_Ctype_uintptr_t /*line :73:38*/(value))
	}
	numValues := len(values)
	var keysPointer, valuesPointer * /*line :76:34*/_Ctype_uintptr_t /*line :76:45*/
	if numValues > 0 {
		keysPointer = &keys[0]
		valuesPointer = &values[0]
	}
	cfDict := func() _Ctype_CFDictionaryRef{ var _cgo0 _Ctype_CFAllocatorRef = /*line :81:38*/*_Cvar_kCFAllocatorDefault /*line :81:59*/; var _cgo1 *_Ctype_uintptr_t = /*line :81:61*/keysPointer; var _cgo2 *_Ctype_uintptr_t = /*line :81:74*/valuesPointer; var _cgo3 _Ctype_CFIndex = _Ctype_CFIndex /*line :81:98*/(numValues); _cgoBase4 := /*line :82:3*/&*_Cvar_kCFTypeDictionaryKeyCallBacks /*line :82:35*/; _cgo4 := _cgoBase4; _cgoBase5 := /*line :82:37*/&*_Cvar_kCFTypeDictionaryValueCallBacks /*line :82:71*/; _cgo5 := _cgoBase5; _cgoCheckPointer(_cgoBase4, 0 == 0); _cgoCheckPointer(_cgoBase5, 0 == 0); return /*line :82:72*/_Cfunc_CFDictionaryCreateSafe2(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() //nolint
	if cfDict == 0 {
		return 0, fmt.Errorf("CFDictionaryCreate failed")
	}
	return cfDict, nil
}

// CFDictionaryToMap converts CFDictionaryRef to a map.
func CFDictionaryToMap(cfDict  /*line :90:31*/_Ctype_CFDictionaryRef /*line :90:48*/) (m map[ /*line :90:57*/_Ctype_CFTypeRef /*line :90:68*/] /*line :90:69*/_Ctype_CFTypeRef /*line :90:80*/) {
	count := func() _Ctype_CFIndex{ var _cgo0 _Ctype_CFDictionaryRef = /*line :91:34*/cfDict; return /*line :91:41*/_Cfunc_CFDictionaryGetCount(_cgo0); }()
	if count > 0 {
		keys := make([] /*line :93:18*/_Ctype_CFTypeRef /*line :93:29*/, count)
		values := make([] /*line :94:20*/_Ctype_CFTypeRef /*line :94:31*/, count)
		func() { var _cgo0 _Ctype_CFDictionaryRef = /*line :95:34*/cfDict; _cgoIndex1 := &/*line :95:76*/keys; _cgo1 := /*line :95:42*/(*unsafe.Pointer)(unsafe.Pointer(&(*_cgoIndex1)[0])); _cgoIndex2 := &/*line :95:121*/values; _cgo2 := /*line :95:87*/(*unsafe.Pointer)(unsafe.Pointer(&(*_cgoIndex2)[0])); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo2, *_cgoIndex2); /*line :95:133*/_Cfunc_CFDictionaryGetKeysAndValues(_cgo0, _cgo1, _cgo2); }()
		m = make(map[ /*line :96:16*/_Ctype_CFTypeRef /*line :96:27*/] /*line :96:28*/_Ctype_CFTypeRef /*line :96:39*/, count)
		for i :=  /*line :97:12*/_Ctype_CFIndex /*line :97:21*/(0); i < count; i++ {
			m[keys[i]] = values[i]
		}
	}
	return
}

// Int32ToCFNumber will return a CFNumberRef, must be released with Release(ref).
func Int32ToCFNumber(u int32)  /*line :105:31*/_Ctype_CFNumberRef /*line :105:44*/ {
	sint :=  /*line :106:10*/_Ctype_SInt32 /*line :106:18*/(u)
	p := unsafe.Pointer(&sint)
	return func() _Ctype_CFNumberRef{ var _cgo0 _Ctype_CFAllocatorRef = /*line :108:26*/*_Cvar_kCFAllocatorDefault /*line :108:47*/; var _cgo1 _Ctype_CFNumberType = /*line :108:49*/_Ciconst_kCFNumberSInt32Type /*line :108:70*/; _cgo2 := /*line :108:72*/p; _cgoCheckPointer(_cgo2, nil); return /*line :108:74*/_Cfunc_CFNumberCreate(_cgo0, _cgo1, _cgo2); }()
}

// StringToCFString will return a CFStringRef and if non-nil, must be released with
// Release(ref).
func StringToCFString(s string) ( /*line :113:34*/_Ctype_CFStringRef /*line :113:47*/, error) {
	if !utf8.ValidString(s) {
		return 0, errors.New("Invalid UTF-8 string")
	}
	if uint64(len(s)) > math.MaxUint32 {
		return 0, errors.New("String is too large")
	}

	bytes := []byte(s)
	var p * /*line :122:9*/_Ctype_UInt8 /*line :122:16*/
	if len(bytes) > 0 {
		p = (* /*line :124:9*/_Ctype_UInt8 /*line :124:16*/)(&bytes[0])
	}
	return func() _Ctype_CFStringRef{ var _cgo0 _Ctype_CFAllocatorRef = /*line :126:35*/*_Cvar_kCFAllocatorDefault /*line :126:56*/; var _cgo1 *_Ctype_UInt8 = /*line :126:58*/p; var _cgo2 _Ctype_CFIndex = _Ctype_CFIndex /*line :126:70*/(len(s)); var _cgo3 _Ctype_CFStringEncoding = /*line :126:80*/_Ciconst_kCFStringEncodingUTF8 /*line :126:103*/; var _cgo4 _Ctype_Boolean = /*line :126:105*/_Ciconst_false /*line :126:112*/; return /*line :126:113*/_Cfunc_CFStringCreateWithBytes(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }(), nil
}

// CFStringToString converts a CFStringRef to a string.
func CFStringToString(s  /*line :130:25*/_Ctype_CFStringRef /*line :130:38*/) string {
	p := func() *_Ctype_char{ var _cgo0 _Ctype_CFStringRef = /*line :131:31*/s; var _cgo1 _Ctype_CFStringEncoding = /*line :131:34*/_Ciconst_kCFStringEncodingUTF8 /*line :131:57*/; return /*line :131:58*/_Cfunc_CFStringGetCStringPtr(_cgo0, _cgo1); }()
	if p != nil {
		return ( /*line :133:10*/_Cfunc_GoString /*line :133:19*/)(p)
	}
	length := func() _Ctype_CFIndex{ var _cgo0 _Ctype_CFStringRef = /*line :135:32*/s; return /*line :135:34*/_Cfunc_CFStringGetLength(_cgo0); }()
	if length == 0 {
		return ""
	}
	maxBufLen := ( /*line :139:15*/_Cfunc_CFStringGetMaximumSizeForEncoding /*line :139:49*/)(length, ( /*line :139:59*/_Ciconst_kCFStringEncodingUTF8 /*line :139:81*/))
	if maxBufLen == 0 {
		return ""
	}
	buf := make([]byte, maxBufLen)
	var usedBufLen  /*line :144:17*/_Ctype_CFIndex /*line :144:26*/
	_ = func() _Ctype_CFIndex{ var _cgo0 _Ctype_CFStringRef = /*line :145:25*/s; var _cgo1 _Ctype_struct___1 = _Ctype_CFRange /*line :145:37*/{0, length}; var _cgo2 _Ctype_CFStringEncoding = /*line :145:50*/_Ciconst_kCFStringEncodingUTF8 /*line :145:73*/; var _cgo3 _Ctype_UInt8 = _Ctype_UInt8 /*line :145:82*/(0); var _cgo4 _Ctype_Boolean = /*line :145:87*/_Ciconst_false /*line :145:94*/; var _cgo5 *_Ctype_UInt8 = /*line :145:96*/(*_Ctype_UInt8 /*line :145:105*/)(&buf[0]); var _cgo6 _Ctype_CFIndex = /*line :145:117*/maxBufLen; var _cgo7 *_Ctype_CFIndex = /*line :145:128*/&usedBufLen; return /*line :145:140*/_Cfunc_CFStringGetBytes(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
	return string(buf[:usedBufLen])
}

// ArrayToCFArray will return a CFArrayRef and if non-nil, must be released with
// Release(ref).
func ArrayToCFArray(a [] /*line :151:25*/_Ctype_CFTypeRef /*line :151:36*/)  /*line :151:38*/_Ctype_CFArrayRef /*line :151:50*/ {
	var values [] /*line :152:15*/_Ctype_uintptr_t /*line :152:26*/
	for _, value := range a {
		values = append(values,  /*line :154:27*/_Ctype_uintptr_t /*line :154:38*/(value))
	}
	numValues := len(values)
	var valuesPointer * /*line :157:21*/_Ctype_uintptr_t /*line :157:32*/
	if numValues > 0 {
		valuesPointer = &values[0]
	}
	return func() _Ctype_CFArrayRef{ var _cgo0 _Ctype_CFAllocatorRef = /*line :161:30*/*_Cvar_kCFAllocatorDefault /*line :161:51*/; var _cgo1 *_Ctype_uintptr_t = /*line :161:53*/valuesPointer; var _cgo2 _Ctype_CFIndex = _Ctype_CFIndex /*line :161:77*/(numValues); _cgoBase3 := /*line :161:90*/&*_Cvar_kCFTypeArrayCallBacks /*line :161:114*/; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :161:115*/_Cfunc_CFArrayCreateSafe2(_cgo0, _cgo1, _cgo2, _cgo3); }() //nolint
}

// CFArrayToArray converts a CFArrayRef to an array of CFTypes.
func CFArrayToArray(cfArray  /*line :165:29*/_Ctype_CFArrayRef /*line :165:41*/) (a [] /*line :165:48*/_Ctype_CFTypeRef /*line :165:59*/) {
	count := func() _Ctype_CFIndex{ var _cgo0 _Ctype_CFArrayRef = /*line :166:29*/cfArray; return /*line :166:37*/_Cfunc_CFArrayGetCount(_cgo0); }()
	if count > 0 {
		a = make([] /*line :168:14*/_Ctype_CFTypeRef /*line :168:25*/, count)
		func() { var _cgo0 _Ctype_CFArrayRef = /*line :169:22*/cfArray; var _cgo1 _Ctype_struct___1 = _Ctype_CFRange /*line :169:40*/{0, count}; _cgoIndex2 := &/*line :169:86*/a; _cgo2 := /*line :169:52*/(*unsafe.Pointer)(unsafe.Pointer(&(*_cgoIndex2)[0])); _cgoCheckPointer(_cgo2, *_cgoIndex2); /*line :169:93*/_Cfunc_CFArrayGetValues(_cgo0, _cgo1, _cgo2); }()
	}
	return
}

// Convertable knows how to convert an instance to a CFTypeRef.
type Convertable interface {
	Convert() ( /*line :176:13*/_Ctype_CFTypeRef /*line :176:24*/, error)
}

// ConvertMapToCFDictionary converts a map to a CFDictionary and if non-nil,
// must be released with Release(ref).
func ConvertMapToCFDictionary(attr map[string]interface{}) ( /*line :181:61*/_Ctype_CFDictionaryRef /*line :181:78*/, error) {
	m := make(map[ /*line :182:16*/_Ctype_CFTypeRef /*line :182:27*/] /*line :182:28*/_Ctype_CFTypeRef /*line :182:39*/)
	for key, i := range attr {
		var valueRef  /*line :184:16*/_Ctype_CFTypeRef /*line :184:27*/
		switch val := i.(type) {
		default:
			return 0, fmt.Errorf("Unsupported value type: %v", reflect.TypeOf(i))
		case  /*line :188:8*/_Ctype_CFTypeRef /*line :188:19*/:
			valueRef = val
		case bool:
			if val {
				valueRef =  /*line :192:16*/_Ctype_CFTypeRef /*line :192:27*/(( /*line :192:28*/*_Cvar_kCFBooleanTrue /*line :192:43*/))
			} else {
				valueRef =  /*line :194:16*/_Ctype_CFTypeRef /*line :194:27*/(( /*line :194:28*/*_Cvar_kCFBooleanFalse /*line :194:44*/))
			}
		case int32:
			valueRef =  /*line :197:15*/_Ctype_CFTypeRef /*line :197:26*/(Int32ToCFNumber(val))
			defer Release(valueRef)
		case []byte:
			bytesRef, err := BytesToCFData(val)
			if err != nil {
				return 0, err
			}
			valueRef =  /*line :204:15*/_Ctype_CFTypeRef /*line :204:26*/(bytesRef)
			defer Release(valueRef)
		case string:
			stringRef, err := StringToCFString(val)
			if err != nil {
				return 0, err
			}
			valueRef =  /*line :211:15*/_Ctype_CFTypeRef /*line :211:26*/(stringRef)
			defer Release(valueRef)
		case Convertable:
			convertedRef, err := val.Convert()
			if err != nil {
				return 0, err
			}
			valueRef = convertedRef
			defer Release(valueRef)
		}
		keyRef, err := StringToCFString(key)
		if err != nil {
			return 0, err
		}
		m[ /*line :225:5*/_Ctype_CFTypeRef /*line :225:16*/(keyRef)] = valueRef
		defer Release( /*line :226:17*/_Ctype_CFTypeRef /*line :226:28*/(keyRef))
	}

	cfDict, err := MapToCFDictionary(m)
	if err != nil {
		return 0, err
	}
	return cfDict, nil
}

// CFTypeDescription returns type string for CFTypeRef.
func CFTypeDescription(ref  /*line :237:28*/_Ctype_CFTypeRef /*line :237:39*/) string {
	typeID := func() _Ctype_CFTypeID{ var _cgo0 _Ctype_CFTypeRef = /*line :238:26*/ref; return /*line :238:30*/_Cfunc_CFGetTypeID(_cgo0); }()
	typeDesc := ( /*line :239:14*/_Cfunc_CFCopyTypeIDDescription /*line :239:38*/)(typeID)
	defer Release( /*line :240:16*/_Ctype_CFTypeRef /*line :240:27*/(typeDesc))
	return CFStringToString(typeDesc)
}

// Convert converts a CFTypeRef to a go instance.
func Convert(ref  /*line :245:18*/_Ctype_CFTypeRef /*line :245:29*/) (interface{}, error) {
	typeID := func() _Ctype_CFTypeID{ var _cgo0 _Ctype_CFTypeRef = /*line :246:26*/ref; return /*line :246:30*/_Cfunc_CFGetTypeID(_cgo0); }()
	if typeID == ( /*line :247:15*/_Cfunc_CFStringGetTypeID /*line :247:33*/)() {
		return CFStringToString( /*line :248:27*/_Ctype_CFStringRef /*line :248:40*/(ref)), nil
	} else if typeID == ( /*line :249:22*/_Cfunc_CFDictionaryGetTypeID /*line :249:44*/)() {
		return ConvertCFDictionary( /*line :250:30*/_Ctype_CFDictionaryRef /*line :250:47*/(ref))
	} else if typeID == ( /*line :251:22*/_Cfunc_CFArrayGetTypeID /*line :251:39*/)() {
		arr := CFArrayToArray( /*line :252:25*/_Ctype_CFArrayRef /*line :252:37*/(ref))
		results := make([]interface{}, 0, len(arr))
		for _, ref := range arr {
			v, err := Convert(ref)
			if err != nil {
				return nil, err
			}
			results = append(results, v)
		}
		return results, nil
	} else if typeID == ( /*line :262:22*/_Cfunc_CFDataGetTypeID /*line :262:38*/)() {
		b, err := CFDataToBytes( /*line :263:27*/_Ctype_CFDataRef /*line :263:38*/(ref))
		if err != nil {
			return nil, err
		}
		return b, nil
	} else if typeID == ( /*line :268:22*/_Cfunc_CFNumberGetTypeID /*line :268:40*/)() {
		return CFNumberToInterface( /*line :269:30*/_Ctype_CFNumberRef /*line :269:43*/(ref)), nil
	} else if typeID == ( /*line :270:22*/_Cfunc_CFBooleanGetTypeID /*line :270:41*/)() {
		if func() _Ctype_Boolean{ var _cgo0 _Ctype_CFBooleanRef = _Ctype_CFBooleanRef /*line :271:40*/(ref); return /*line :271:46*/_Cfunc_CFBooleanGetValue(_cgo0); }() != 0 {
			return true, nil
		}
		return false, nil
	}

	return nil, fmt.Errorf("Invalid type: %s", CFTypeDescription(ref))
}

// ConvertCFDictionary converts a CFDictionary to map (deep).
func ConvertCFDictionary(d  /*line :281:28*/_Ctype_CFDictionaryRef /*line :281:45*/) (map[interface{}]interface{}, error) {
	m := CFDictionaryToMap(d)
	result := make(map[interface{}]interface{})

	for k, v := range m {
		gk, err := Convert(k)
		if err != nil {
			return nil, err
		}
		gv, err := Convert(v)
		if err != nil {
			return nil, err
		}
		result[gk] = gv
	}
	return result, nil
}

// CFNumberToInterface converts the CFNumberRef to the most appropriate numeric
// type.
// This code is from github.com/kballard/go-osx-plist.
func CFNumberToInterface(cfNumber  /*line :302:35*/_Ctype_CFNumberRef /*line :302:48*/) interface{} {
	typ := func() _Ctype_CFNumberType{ var _cgo0 _Ctype_CFNumberRef = /*line :303:27*/cfNumber; return /*line :303:36*/_Cfunc_CFNumberGetType(_cgo0); }()
	switch typ {
	case ( /*line :305:7*/_Ciconst_kCFNumberSInt8Type /*line :305:26*/):
		var sint  /*line :306:12*/_Ctype_SInt8 /*line :306:19*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :307:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :307:32*/typ; _cgoBase2 := /*line :307:52*/&sint; _cgo2 := /*line :307:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :307:59*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int8(sint)
	case ( /*line :309:7*/_Ciconst_kCFNumberSInt16Type /*line :309:27*/):
		var sint  /*line :310:12*/_Ctype_SInt16 /*line :310:20*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :311:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :311:32*/typ; _cgoBase2 := /*line :311:52*/&sint; _cgo2 := /*line :311:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :311:59*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int16(sint)
	case ( /*line :313:7*/_Ciconst_kCFNumberSInt32Type /*line :313:27*/):
		var sint  /*line :314:12*/_Ctype_SInt32 /*line :314:20*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :315:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :315:32*/typ; _cgoBase2 := /*line :315:52*/&sint; _cgo2 := /*line :315:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :315:59*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int32(sint)
	case ( /*line :317:7*/_Ciconst_kCFNumberSInt64Type /*line :317:27*/):
		var sint  /*line :318:12*/_Ctype_SInt64 /*line :318:20*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :319:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :319:32*/typ; _cgoBase2 := /*line :319:52*/&sint; _cgo2 := /*line :319:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :319:59*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int64(sint)
	case ( /*line :321:7*/_Ciconst_kCFNumberFloat32Type /*line :321:28*/):
		var float  /*line :322:13*/_Ctype_Float32 /*line :322:22*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :323:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :323:32*/typ; _cgoBase2 := /*line :323:52*/&float; _cgo2 := /*line :323:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :323:60*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return float32(float)
	case ( /*line :325:7*/_Ciconst_kCFNumberFloat64Type /*line :325:28*/):
		var float  /*line :326:13*/_Ctype_Float64 /*line :326:22*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :327:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :327:32*/typ; _cgoBase2 := /*line :327:52*/&float; _cgo2 := /*line :327:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :327:60*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return float64(float)
	case ( /*line :329:7*/_Ciconst_kCFNumberCharType /*line :329:25*/):
		var char  /*line :330:12*/_Ctype_char /*line :330:18*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :331:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :331:32*/typ; _cgoBase2 := /*line :331:52*/&char; _cgo2 := /*line :331:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :331:59*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return byte(char)
	case ( /*line :333:7*/_Ciconst_kCFNumberShortType /*line :333:26*/):
		var short  /*line :334:13*/_Ctype_short /*line :334:20*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :335:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :335:32*/typ; _cgoBase2 := /*line :335:52*/&short; _cgo2 := /*line :335:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :335:60*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int16(short)
	case ( /*line :337:7*/_Ciconst_kCFNumberIntType /*line :337:24*/):
		var i  /*line :338:9*/_Ctype_int /*line :338:14*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :339:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :339:32*/typ; _cgoBase2 := /*line :339:52*/&i; _cgo2 := /*line :339:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :339:56*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int32(i)
	case ( /*line :341:7*/_Ciconst_kCFNumberLongType /*line :341:25*/):
		var long  /*line :342:12*/_Ctype_long /*line :342:18*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :343:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :343:32*/typ; _cgoBase2 := /*line :343:52*/&long; _cgo2 := /*line :343:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :343:59*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int(long)
	case ( /*line :345:7*/_Ciconst_kCFNumberLongLongType /*line :345:29*/):
		// This is the only type that may actually overflow us
		var longlong  /*line :347:16*/_Ctype_longlong /*line :347:26*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :348:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :348:32*/typ; _cgoBase2 := /*line :348:52*/&longlong; _cgo2 := /*line :348:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :348:63*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int64(longlong)
	case ( /*line :350:7*/_Ciconst_kCFNumberFloatType /*line :350:26*/):
		var float  /*line :351:13*/_Ctype_float /*line :351:20*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :352:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :352:32*/typ; _cgoBase2 := /*line :352:52*/&float; _cgo2 := /*line :352:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :352:60*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return float32(float)
	case ( /*line :354:7*/_Ciconst_kCFNumberDoubleType /*line :354:27*/):
		var double  /*line :355:14*/_Ctype_double /*line :355:22*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :356:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :356:32*/typ; _cgoBase2 := /*line :356:52*/&double; _cgo2 := /*line :356:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :356:61*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return float64(double)
	case ( /*line :358:7*/_Ciconst_kCFNumberCFIndexType /*line :358:28*/):
		// CFIndex is a long
		var index  /*line :360:13*/_Ctype_CFIndex /*line :360:22*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :361:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :361:32*/typ; _cgoBase2 := /*line :361:52*/&index; _cgo2 := /*line :361:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :361:60*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int(index)
	case ( /*line :363:7*/_Ciconst_kCFNumberNSIntegerType /*line :363:30*/):
		// We don't have a definition of NSInteger, but we know it's either an int or a long
		var nsInt  /*line :365:13*/_Ctype_long /*line :365:19*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :366:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :366:32*/typ; _cgoBase2 := /*line :366:52*/&nsInt; _cgo2 := /*line :366:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :366:60*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int(nsInt)
	}
	panic("Unknown CFNumber type")
}
