// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/jamesonzeller/go/pkg/mod/github.com/keybase/go-keychain@v0.0.1/keychain.go:1:1
//go:build darwin
// +build darwin

package keychain

// See https://developer.apple.com/library/ios/documentation/Security/Reference/keychainservices/index.html for the APIs used below.

// Also see https://developer.apple.com/library/ios/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html .

/*
#cgo LDFLAGS: -framework CoreFoundation -framework Security

#include <CoreFoundation/CoreFoundation.h>
#include <Security/Security.h>
*/
import _ "unsafe"
import (
	"fmt"
	"time"
)

// Error defines keychain errors
type Error int

var (
	// ErrorUnimplemented corresponds to errSecUnimplemented result code
	ErrorUnimplemented = Error(( /*line :27:29*/_Ciconst_errSecUnimplemented /*line :27:49*/))
	// ErrorParam corresponds to errSecParam result code
	ErrorParam = Error(( /*line :29:21*/_Ciconst_errSecParam /*line :29:33*/))
	// ErrorAllocate corresponds to errSecAllocate result code
	ErrorAllocate = Error(( /*line :31:24*/_Ciconst_errSecAllocate /*line :31:39*/))
	// ErrorNotAvailable corresponds to errSecNotAvailable result code
	ErrorNotAvailable = Error(( /*line :33:28*/_Ciconst_errSecNotAvailable /*line :33:47*/))
	// ErrorAuthFailed corresponds to errSecAuthFailed result code
	ErrorAuthFailed = Error(( /*line :35:26*/_Ciconst_errSecAuthFailed /*line :35:43*/))
	// ErrorDuplicateItem corresponds to errSecDuplicateItem result code
	ErrorDuplicateItem = Error(( /*line :37:29*/_Ciconst_errSecDuplicateItem /*line :37:49*/))
	// ErrorItemNotFound corresponds to errSecItemNotFound result code
	ErrorItemNotFound = Error(( /*line :39:28*/_Ciconst_errSecItemNotFound /*line :39:47*/))
	// ErrorInteractionNotAllowed corresponds to errSecInteractionNotAllowed result code
	ErrorInteractionNotAllowed = Error(( /*line :41:37*/_Ciconst_errSecInteractionNotAllowed /*line :41:65*/))
	// ErrorDecode corresponds to errSecDecode result code
	ErrorDecode = Error(( /*line :43:22*/_Ciconst_errSecDecode /*line :43:35*/))
	// ErrorNoSuchKeychain corresponds to errSecNoSuchKeychain result code
	ErrorNoSuchKeychain = Error(( /*line :45:30*/_Ciconst_errSecNoSuchKeychain /*line :45:51*/))
	// ErrorNoAccessForItem corresponds to errSecNoAccessForItem result code
	ErrorNoAccessForItem = Error(( /*line :47:31*/_Ciconst_errSecNoAccessForItem /*line :47:53*/))
	// ErrorReadOnly corresponds to errSecReadOnly result code
	ErrorReadOnly = Error(( /*line :49:24*/_Ciconst_errSecReadOnly /*line :49:39*/))
	// ErrorInvalidKeychain corresponds to errSecInvalidKeychain result code
	ErrorInvalidKeychain = Error(( /*line :51:31*/_Ciconst_errSecInvalidKeychain /*line :51:53*/))
	// ErrorDuplicateKeyChain corresponds to errSecDuplicateKeychain result code
	ErrorDuplicateKeyChain = Error(( /*line :53:33*/_Ciconst_errSecDuplicateKeychain /*line :53:57*/))
	// ErrorWrongVersion corresponds to errSecWrongSecVersion result code
	ErrorWrongVersion = Error(( /*line :55:28*/_Ciconst_errSecWrongSecVersion /*line :55:50*/))
	// ErrorReadonlyAttribute corresponds to errSecReadOnlyAttr result code
	ErrorReadonlyAttribute = Error(( /*line :57:33*/_Ciconst_errSecReadOnlyAttr /*line :57:52*/))
	// ErrorInvalidSearchRef corresponds to errSecInvalidSearchRef result code
	ErrorInvalidSearchRef = Error(( /*line :59:32*/_Ciconst_errSecInvalidSearchRef /*line :59:55*/))
	// ErrorInvalidItemRef corresponds to errSecInvalidItemRef result code
	ErrorInvalidItemRef = Error(( /*line :61:30*/_Ciconst_errSecInvalidItemRef /*line :61:51*/))
	// ErrorDataNotAvailable corresponds to errSecDataNotAvailable result code
	ErrorDataNotAvailable = Error(( /*line :63:32*/_Ciconst_errSecDataNotAvailable /*line :63:55*/))
	// ErrorDataNotModifiable corresponds to errSecDataNotModifiable result code
	ErrorDataNotModifiable = Error(( /*line :65:33*/_Ciconst_errSecDataNotModifiable /*line :65:57*/))
	// ErrorInvalidOwnerEdit corresponds to errSecInvalidOwnerEdit result code
	ErrorInvalidOwnerEdit = Error(( /*line :67:32*/_Ciconst_errSecInvalidOwnerEdit /*line :67:55*/))
	// ErrorUserCanceled corresponds to errSecUserCanceled result code
	ErrorUserCanceled = Error(( /*line :69:28*/_Ciconst_errSecUserCanceled /*line :69:47*/))
)

func checkError(errCode  /*line :72:25*/_Ctype_OSStatus /*line :72:35*/) error {
	if errCode == ( /*line :73:16*/_Ciconst_errSecSuccess /*line :73:30*/) {
		return nil
	}
	return Error(errCode)
}

func (k Error) Error() (msg string) {
	// SecCopyErrorMessageString is only available on OSX, so derive manually.
	// Messages derived from `$ security error $errcode`.
	switch k {
	case ErrorUnimplemented:
		msg = "Function or operation not implemented."
	case ErrorParam:
		msg = "One or more parameters passed to the function were not valid."
	case ErrorAllocate:
		msg = "Failed to allocate memory."
	case ErrorNotAvailable:
		msg = "No keychain is available. You may need to restart your computer."
	case ErrorAuthFailed:
		msg = "The user name or passphrase you entered is not correct."
	case ErrorDuplicateItem:
		msg = "The specified item already exists in the keychain."
	case ErrorItemNotFound:
		msg = "The specified item could not be found in the keychain."
	case ErrorInteractionNotAllowed:
		msg = "User interaction is not allowed."
	case ErrorDecode:
		msg = "Unable to decode the provided data."
	case ErrorNoSuchKeychain:
		msg = "The specified keychain could not be found."
	case ErrorNoAccessForItem:
		msg = "The specified item has no access control."
	case ErrorReadOnly:
		msg = "Read-only error."
	case ErrorReadonlyAttribute:
		msg = "The attribute is read-only."
	case ErrorInvalidKeychain:
		msg = "The keychain is not valid."
	case ErrorDuplicateKeyChain:
		msg = "A keychain with the same name already exists."
	case ErrorWrongVersion:
		msg = "The version is incorrect."
	case ErrorInvalidItemRef:
		msg = "The item reference is invalid."
	case ErrorInvalidSearchRef:
		msg = "The search reference is invalid."
	case ErrorDataNotAvailable:
		msg = "The data is not available."
	case ErrorDataNotModifiable:
		msg = "The data is not modifiable."
	case ErrorInvalidOwnerEdit:
		msg = "An invalid attempt to change the owner of an item."
	case ErrorUserCanceled:
		msg = "User canceled the operation."
	default:
		msg = "Keychain Error."
	}
	return fmt.Sprintf("%s (%d)", msg, k)
}

// SecClass is the items class code
type SecClass int

// Keychain Item Classes
var (
	/*
		kSecClassGenericPassword item attributes:
		 kSecAttrAccess (OS X only)
		 kSecAttrAccessGroup (iOS; also OS X if kSecAttrSynchronizable specified)
		 kSecAttrAccessible (iOS; also OS X if kSecAttrSynchronizable specified)
		 kSecAttrAccount
		 kSecAttrService
	*/
	SecClassGenericPassword  SecClass = 1
	SecClassInternetPassword SecClass = 2
)

// SecClassKey is the key type for SecClass
var SecClassKey = attrKey( /*line :151:27*/_Ctype_CFTypeRef /*line :151:38*/(( /*line :151:39*/*_Cvar_kSecClass /*line :151:49*/)))
var secClassTypeRef = map[SecClass] /*line :152:36*/_Ctype_CFTypeRef /*line :152:47*/{
	SecClassGenericPassword:   /*line :153:28*/_Ctype_CFTypeRef /*line :153:39*/(( /*line :153:40*/*_Cvar_kSecClassGenericPassword /*line :153:65*/)),
	SecClassInternetPassword:  /*line :154:28*/_Ctype_CFTypeRef /*line :154:39*/(( /*line :154:40*/*_Cvar_kSecClassInternetPassword /*line :154:66*/)),
}

var (
	// ServiceKey is for kSecAttrService
	ServiceKey = attrKey( /*line :159:23*/_Ctype_CFTypeRef /*line :159:34*/(( /*line :159:35*/*_Cvar_kSecAttrService /*line :159:51*/)))

	// ServerKey is for kSecAttrServer
	ServerKey = attrKey( /*line :162:22*/_Ctype_CFTypeRef /*line :162:33*/(( /*line :162:34*/*_Cvar_kSecAttrServer /*line :162:49*/)))
	// ProtocolKey is for kSecAttrProtocol
	ProtocolKey = attrKey( /*line :164:24*/_Ctype_CFTypeRef /*line :164:35*/(( /*line :164:36*/*_Cvar_kSecAttrProtocol /*line :164:53*/)))
	// AuthenticationTypeKey is for kSecAttrAuthenticationType
	AuthenticationTypeKey = attrKey( /*line :166:34*/_Ctype_CFTypeRef /*line :166:45*/(( /*line :166:46*/*_Cvar_kSecAttrAuthenticationType /*line :166:73*/)))
	// PortKey is for kSecAttrPort
	PortKey = attrKey( /*line :168:20*/_Ctype_CFTypeRef /*line :168:31*/(( /*line :168:32*/*_Cvar_kSecAttrPort /*line :168:45*/)))
	// PathKey is for kSecAttrPath
	PathKey = attrKey( /*line :170:20*/_Ctype_CFTypeRef /*line :170:31*/(( /*line :170:32*/*_Cvar_kSecAttrPath /*line :170:45*/)))

	// LabelKey is for kSecAttrLabel
	LabelKey = attrKey( /*line :173:21*/_Ctype_CFTypeRef /*line :173:32*/(( /*line :173:33*/*_Cvar_kSecAttrLabel /*line :173:47*/)))
	// AccountKey is for kSecAttrAccount
	AccountKey = attrKey( /*line :175:23*/_Ctype_CFTypeRef /*line :175:34*/(( /*line :175:35*/*_Cvar_kSecAttrAccount /*line :175:51*/)))
	// AccessGroupKey is for kSecAttrAccessGroup
	AccessGroupKey = attrKey( /*line :177:27*/_Ctype_CFTypeRef /*line :177:38*/(( /*line :177:39*/*_Cvar_kSecAttrAccessGroup /*line :177:59*/)))
	// DataKey is for kSecValueData
	DataKey = attrKey( /*line :179:20*/_Ctype_CFTypeRef /*line :179:31*/(( /*line :179:32*/*_Cvar_kSecValueData /*line :179:46*/)))
	// DescriptionKey is for kSecAttrDescription
	DescriptionKey = attrKey( /*line :181:27*/_Ctype_CFTypeRef /*line :181:38*/(( /*line :181:39*/*_Cvar_kSecAttrDescription /*line :181:59*/)))
	// CommentKey is for kSecAttrComment
	CommentKey = attrKey( /*line :183:23*/_Ctype_CFTypeRef /*line :183:34*/(( /*line :183:35*/*_Cvar_kSecAttrComment /*line :183:51*/)))
	// CreationDateKey is for kSecAttrCreationDate
	CreationDateKey = attrKey( /*line :185:28*/_Ctype_CFTypeRef /*line :185:39*/(( /*line :185:40*/*_Cvar_kSecAttrCreationDate /*line :185:61*/)))
	// ModificationDateKey is for kSecAttrModificationDate
	ModificationDateKey = attrKey( /*line :187:32*/_Ctype_CFTypeRef /*line :187:43*/(( /*line :187:44*/*_Cvar_kSecAttrModificationDate /*line :187:69*/)))
)

// Synchronizable is the items synchronizable status
type Synchronizable int

const (
	// SynchronizableDefault is the default setting
	SynchronizableDefault Synchronizable = 0
	// SynchronizableAny is for kSecAttrSynchronizableAny
	SynchronizableAny = 1
	// SynchronizableYes enables synchronization
	SynchronizableYes = 2
	// SynchronizableNo disables synchronization
	SynchronizableNo = 3
)

// SynchronizableKey is the key type for Synchronizable
var SynchronizableKey = attrKey( /*line :205:33*/_Ctype_CFTypeRef /*line :205:44*/(( /*line :205:45*/*_Cvar_kSecAttrSynchronizable /*line :205:68*/)))
var syncTypeRef = map[Synchronizable] /*line :206:38*/_Ctype_CFTypeRef /*line :206:49*/{
	SynchronizableAny:  /*line :207:21*/_Ctype_CFTypeRef /*line :207:32*/(( /*line :207:33*/*_Cvar_kSecAttrSynchronizableAny /*line :207:59*/)),
	SynchronizableYes:  /*line :208:21*/_Ctype_CFTypeRef /*line :208:32*/(( /*line :208:33*/*_Cvar_kCFBooleanTrue /*line :208:48*/)),
	SynchronizableNo:   /*line :209:21*/_Ctype_CFTypeRef /*line :209:32*/(( /*line :209:33*/*_Cvar_kCFBooleanFalse /*line :209:49*/)),
}

// Accessible is the items accessibility
type Accessible int

const (
	// AccessibleDefault is the default
	AccessibleDefault Accessible = 0
	// AccessibleWhenUnlocked is when unlocked
	AccessibleWhenUnlocked = 1
	// AccessibleAfterFirstUnlock is after first unlock
	AccessibleAfterFirstUnlock = 2
	// AccessibleAlways is always
	AccessibleAlways = 3
	// AccessibleWhenPasscodeSetThisDeviceOnly is when passcode is set
	AccessibleWhenPasscodeSetThisDeviceOnly = 4
	// AccessibleWhenUnlockedThisDeviceOnly is when unlocked for this device only
	AccessibleWhenUnlockedThisDeviceOnly = 5
	// AccessibleAfterFirstUnlockThisDeviceOnly is after first unlock for this device only
	AccessibleAfterFirstUnlockThisDeviceOnly = 6
	// AccessibleAccessibleAlwaysThisDeviceOnly is always for this device only
	AccessibleAccessibleAlwaysThisDeviceOnly = 7
)

// MatchLimit is whether to limit results on query
type MatchLimit int

const (
	// MatchLimitDefault is the default
	MatchLimitDefault MatchLimit = 0
	// MatchLimitOne limits to one result
	MatchLimitOne = 1
	// MatchLimitAll is no limit
	MatchLimitAll = 2
)

// MatchLimitKey is key type for MatchLimit
var MatchLimitKey = attrKey( /*line :247:29*/_Ctype_CFTypeRef /*line :247:40*/(( /*line :247:41*/*_Cvar_kSecMatchLimit /*line :247:56*/)))
var matchTypeRef = map[MatchLimit] /*line :248:35*/_Ctype_CFTypeRef /*line :248:46*/{
	MatchLimitOne:  /*line :249:17*/_Ctype_CFTypeRef /*line :249:28*/(( /*line :249:29*/*_Cvar_kSecMatchLimitOne /*line :249:47*/)),
	MatchLimitAll:  /*line :250:17*/_Ctype_CFTypeRef /*line :250:28*/(( /*line :250:29*/*_Cvar_kSecMatchLimitAll /*line :250:47*/)),
}

// ReturnAttributesKey is key type for kSecReturnAttributes
var ReturnAttributesKey = attrKey( /*line :254:35*/_Ctype_CFTypeRef /*line :254:46*/(( /*line :254:47*/*_Cvar_kSecReturnAttributes /*line :254:68*/)))

// ReturnDataKey is key type for kSecReturnData
var ReturnDataKey = attrKey( /*line :257:29*/_Ctype_CFTypeRef /*line :257:40*/(( /*line :257:41*/*_Cvar_kSecReturnData /*line :257:56*/)))

// ReturnRefKey is key type for kSecReturnRef
var ReturnRefKey = attrKey( /*line :260:28*/_Ctype_CFTypeRef /*line :260:39*/(( /*line :260:40*/*_Cvar_kSecReturnRef /*line :260:54*/)))

// Item for adding, querying or deleting.
type Item struct {
	// Values can be string, []byte, Convertable or CFTypeRef (constant).
	attr map[string]interface{}
}

// SetSecClass sets the security class
func (k *Item) SetSecClass(sc SecClass) {
	k.attr[SecClassKey] = secClassTypeRef[sc]
}

// SetInt32 sets an int32 attribute for a string key
func (k *Item) SetInt32(key string, v int32) {
	if v != 0 {
		k.attr[key] = v
	} else {
		delete(k.attr, key)
	}
}

// SetString sets a string attibute for a string key
func (k *Item) SetString(key string, s string) {
	if s != "" {
		k.attr[key] = s
	} else {
		delete(k.attr, key)
	}
}

// SetService sets the service attribute (for generic application items)
func (k *Item) SetService(s string) {
	k.SetString(ServiceKey, s)
}

// SetServer sets the server attribute (for internet password items)
func (k *Item) SetServer(s string) {
	k.SetString(ServerKey, s)
}

// SetProtocol sets the protocol attribute (for internet password items)
// Example values are: "htps", "http", "smb "
func (k *Item) SetProtocol(s string) {
	k.SetString(ProtocolKey, s)
}

// SetAuthenticationType sets the authentication type attribute (for internet password items)
func (k *Item) SetAuthenticationType(s string) {
	k.SetString(AuthenticationTypeKey, s)
}

// SetPort sets the port attribute (for internet password items)
func (k *Item) SetPort(v int32) {
	k.SetInt32(PortKey, v)
}

// SetPath sets the path attribute (for internet password items)
func (k *Item) SetPath(s string) {
	k.SetString(PathKey, s)
}

// SetAccount sets the account attribute
func (k *Item) SetAccount(a string) {
	k.SetString(AccountKey, a)
}

// SetLabel sets the label attribute
func (k *Item) SetLabel(l string) {
	k.SetString(LabelKey, l)
}

// SetDescription sets the description attribute
func (k *Item) SetDescription(s string) {
	k.SetString(DescriptionKey, s)
}

// SetComment sets the comment attribute
func (k *Item) SetComment(s string) {
	k.SetString(CommentKey, s)
}

// SetData sets the data attribute
func (k *Item) SetData(b []byte) {
	if b != nil {
		k.attr[DataKey] = b
	} else {
		delete(k.attr, DataKey)
	}
}

// SetAccessGroup sets the access group attribute
func (k *Item) SetAccessGroup(ag string) {
	k.SetString(AccessGroupKey, ag)
}

// SetSynchronizable sets the synchronizable attribute
func (k *Item) SetSynchronizable(sync Synchronizable) {
	if sync != SynchronizableDefault {
		k.attr[SynchronizableKey] = syncTypeRef[sync]
	} else {
		delete(k.attr, SynchronizableKey)
	}
}

// SetAccessible sets the accessible attribute
func (k *Item) SetAccessible(accessible Accessible) {
	if accessible != AccessibleDefault {
		k.attr[AccessibleKey] = accessibleTypeRef[accessible]
	} else {
		delete(k.attr, AccessibleKey)
	}
}

// SetMatchLimit sets the match limit
func (k *Item) SetMatchLimit(matchLimit MatchLimit) {
	if matchLimit != MatchLimitDefault {
		k.attr[MatchLimitKey] = matchTypeRef[matchLimit]
	} else {
		delete(k.attr, MatchLimitKey)
	}
}

// SetReturnAttributes sets the return value type on query
func (k *Item) SetReturnAttributes(b bool) {
	k.attr[ReturnAttributesKey] = b
}

// SetReturnData enables returning data on query
func (k *Item) SetReturnData(b bool) {
	k.attr[ReturnDataKey] = b
}

// SetReturnRef enables returning references on query
func (k *Item) SetReturnRef(b bool) {
	k.attr[ReturnRefKey] = b
}

// NewItem is a new empty keychain item
func NewItem() Item {
	return Item{make(map[string]interface{})}
}

// NewGenericPassword creates a generic password item with the default keychain. This is a convenience method.
func NewGenericPassword(service string, account string, label string, data []byte, accessGroup string) Item {
	item := NewItem()
	item.SetSecClass(SecClassGenericPassword)
	item.SetService(service)
	item.SetAccount(account)
	item.SetLabel(label)
	item.SetData(data)
	item.SetAccessGroup(accessGroup)
	return item
}

// AddItem adds a Item to a Keychain
func AddItem(item Item) error {
	cfDict, err := ConvertMapToCFDictionary(item.attr)
	if err != nil {
		return err
	}
	defer Release( /*line :421:16*/_Ctype_CFTypeRef /*line :421:27*/(cfDict))

	errCode := func() _Ctype_OSStatus{ var _cgo0 _Ctype_CFDictionaryRef = /*line :423:26*/cfDict; var _cgo1 *_Ctype_CFTypeRef = /*line :423:34*/nil; return /*line :423:38*/_Cfunc_SecItemAdd(_cgo0, _cgo1); }()
	err = checkError(errCode)
	return err
}

// UpdateItem updates the queryItem with the parameters from updateItem
func UpdateItem(queryItem Item, updateItem Item) error {
	cfDict, err := ConvertMapToCFDictionary(queryItem.attr)
	if err != nil {
		return err
	}
	defer Release( /*line :434:16*/_Ctype_CFTypeRef /*line :434:27*/(cfDict))
	cfDictUpdate, err := ConvertMapToCFDictionary(updateItem.attr)
	if err != nil {
		return err
	}
	defer Release( /*line :439:16*/_Ctype_CFTypeRef /*line :439:27*/(cfDictUpdate))
	errCode := func() _Ctype_OSStatus{ var _cgo0 _Ctype_CFDictionaryRef = /*line :440:29*/cfDict; var _cgo1 _Ctype_CFDictionaryRef = /*line :440:37*/cfDictUpdate; return /*line :440:50*/_Cfunc_SecItemUpdate(_cgo0, _cgo1); }()
	err = checkError(errCode)
	return err
}

// QueryResult stores all possible results from queries.
// Not all fields are applicable all the time. Results depend on query.
type QueryResult struct {
	// For generic application items
	Service string

	// For internet password items
	Server             string
	Protocol           string
	AuthenticationType string
	Port               int32
	Path               string

	Account          string
	AccessGroup      string
	Label            string
	Description      string
	Comment          string
	Data             []byte
	CreationDate     time.Time
	ModificationDate time.Time
}

// QueryItemRef returns query result as CFTypeRef. You must release it when you are done.
func QueryItemRef(item Item) ( /*line :469:31*/_Ctype_CFTypeRef /*line :469:42*/, error) {
	cfDict, err := ConvertMapToCFDictionary(item.attr)
	if err != nil {
		return 0, err
	}
	defer Release( /*line :474:16*/_Ctype_CFTypeRef /*line :474:27*/(cfDict))

	var resultsRef  /*line :476:17*/_Ctype_CFTypeRef /*line :476:28*/
	errCode := func() _Ctype_OSStatus{ var _cgo0 _Ctype_CFDictionaryRef = /*line :477:35*/cfDict; _cgoBase1 := /*line :477:43*/&resultsRef; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :477:55*/_Cfunc_SecItemCopyMatching(_cgo0, _cgo1); }() //nolint
	if Error(errCode) == ErrorItemNotFound {
		return 0, nil
	}
	err = checkError(errCode)
	if err != nil {
		return 0, err
	}
	return resultsRef, nil
}

// QueryItem returns a list of query results.
func QueryItem(item Item) ([]QueryResult, error) {
	resultsRef, err := QueryItemRef(item)
	if err != nil {
		return nil, err
	}
	if resultsRef == 0 {
		return nil, nil
	}
	defer Release(resultsRef)

	results := make([]QueryResult, 0, 1)

	typeID := func() _Ctype_CFTypeID{ var _cgo0 _Ctype_CFTypeRef = /*line :501:26*/resultsRef; return /*line :501:37*/_Cfunc_CFGetTypeID(_cgo0); }()
	if typeID == ( /*line :502:15*/_Cfunc_CFArrayGetTypeID /*line :502:32*/)() {
		arr := CFArrayToArray( /*line :503:25*/_Ctype_CFArrayRef /*line :503:37*/(resultsRef))
		for _, ref := range arr {
			elementTypeID := func() _Ctype_CFTypeID{ var _cgo0 _Ctype_CFTypeRef = /*line :505:35*/ref; return /*line :505:39*/_Cfunc_CFGetTypeID(_cgo0); }()
			if elementTypeID == ( /*line :506:24*/_Cfunc_CFDictionaryGetTypeID /*line :506:46*/)() {
				item, err := convertResult( /*line :507:32*/_Ctype_CFDictionaryRef /*line :507:49*/(ref))
				if err != nil {
					return nil, err
				}
				results = append(results, *item)
			} else {
				return nil, fmt.Errorf("invalid result type (If you SetReturnRef(true) you should use QueryItemRef directly)")
			}
		}
	} else if typeID == ( /*line :516:22*/_Cfunc_CFDictionaryGetTypeID /*line :516:44*/)() {
		item, err := convertResult( /*line :517:30*/_Ctype_CFDictionaryRef /*line :517:47*/(resultsRef))
		if err != nil {
			return nil, err
		}
		results = append(results, *item)
	} else if typeID == ( /*line :522:22*/_Cfunc_CFDataGetTypeID /*line :522:38*/)() {
		b, err := CFDataToBytes( /*line :523:27*/_Ctype_CFDataRef /*line :523:38*/(resultsRef))
		if err != nil {
			return nil, err
		}
		item := QueryResult{Data: b}
		results = append(results, item)
	} else {
		return nil, fmt.Errorf("Invalid result type: %s", CFTypeDescription(resultsRef))
	}

	return results, nil
}

func attrKey(ref  /*line :536:18*/_Ctype_CFTypeRef /*line :536:29*/) string {
	return CFStringToString( /*line :537:26*/_Ctype_CFStringRef /*line :537:39*/(ref))
}

func convertResult(d  /*line :540:22*/_Ctype_CFDictionaryRef /*line :540:39*/) (*QueryResult, error) {
	m := CFDictionaryToMap(d)
	result := QueryResult{}
	for k, v := range m {
		switch attrKey(k) {
		case ServiceKey:
			result.Service = CFStringToString( /*line :546:38*/_Ctype_CFStringRef /*line :546:51*/(v))
		case ServerKey:
			result.Server = CFStringToString( /*line :548:37*/_Ctype_CFStringRef /*line :548:50*/(v))
		case ProtocolKey:
			result.Protocol = CFStringToString( /*line :550:39*/_Ctype_CFStringRef /*line :550:52*/(v))
		case AuthenticationTypeKey:
			result.AuthenticationType = CFStringToString( /*line :552:49*/_Ctype_CFStringRef /*line :552:62*/(v))
		case PortKey:
			val := CFNumberToInterface( /*line :554:31*/_Ctype_CFNumberRef /*line :554:44*/(v))
			result.Port = val.(int32)
		case PathKey:
			result.Path = CFStringToString( /*line :557:35*/_Ctype_CFStringRef /*line :557:48*/(v))
		case AccountKey:
			result.Account = CFStringToString( /*line :559:38*/_Ctype_CFStringRef /*line :559:51*/(v))
		case AccessGroupKey:
			result.AccessGroup = CFStringToString( /*line :561:42*/_Ctype_CFStringRef /*line :561:55*/(v))
		case LabelKey:
			result.Label = CFStringToString( /*line :563:36*/_Ctype_CFStringRef /*line :563:49*/(v))
		case DescriptionKey:
			result.Description = CFStringToString( /*line :565:42*/_Ctype_CFStringRef /*line :565:55*/(v))
		case CommentKey:
			result.Comment = CFStringToString( /*line :567:38*/_Ctype_CFStringRef /*line :567:51*/(v))
		case DataKey:
			b, err := CFDataToBytes( /*line :569:28*/_Ctype_CFDataRef /*line :569:39*/(v))
			if err != nil {
				return nil, err
			}
			result.Data = b
		case CreationDateKey:
			result.CreationDate = CFDateToTime( /*line :575:39*/_Ctype_CFDateRef /*line :575:50*/(v))
		case ModificationDateKey:
			result.ModificationDate = CFDateToTime( /*line :577:43*/_Ctype_CFDateRef /*line :577:54*/(v))
			// default:
			// fmt.Printf("Unhandled key in conversion: %v = %v\n", cfTypeValue(k), cfTypeValue(v))
		}
	}
	return &result, nil
}

// DeleteGenericPasswordItem removes a generic password item.
func DeleteGenericPasswordItem(service string, account string) error {
	item := NewItem()
	item.SetSecClass(SecClassGenericPassword)
	item.SetService(service)
	item.SetAccount(account)
	return DeleteItem(item)
}

// DeleteItem removes a Item
func DeleteItem(item Item) error {
	cfDict, err := ConvertMapToCFDictionary(item.attr)
	if err != nil {
		return err
	}
	defer Release( /*line :600:16*/_Ctype_CFTypeRef /*line :600:27*/(cfDict))

	errCode := func() _Ctype_OSStatus{ var _cgo0 _Ctype_CFDictionaryRef = /*line :602:29*/cfDict; return /*line :602:36*/_Cfunc_SecItemDelete(_cgo0); }()
	return checkError(errCode)
}

// GetAccountsForService is deprecated
func GetAccountsForService(service string) ([]string, error) {
	return GetGenericPasswordAccounts(service)
}

// GetGenericPasswordAccounts returns generic password accounts for service. This is a convenience method.
func GetGenericPasswordAccounts(service string) ([]string, error) {
	query := NewItem()
	query.SetSecClass(SecClassGenericPassword)
	query.SetService(service)
	query.SetMatchLimit(MatchLimitAll)
	query.SetReturnAttributes(true)
	results, err := QueryItem(query)
	if err != nil {
		return nil, err
	}

	accounts := make([]string, 0, len(results))
	for _, r := range results {
		accounts = append(accounts, r.Account)
	}

	return accounts, nil
}

// GetGenericPassword returns password data for service and account. This is a convenience method.
// If item is not found returns nil, nil.
func GetGenericPassword(service string, account string, label string, accessGroup string) ([]byte, error) {
	query := NewItem()
	query.SetSecClass(SecClassGenericPassword)
	query.SetService(service)
	query.SetAccount(account)
	query.SetLabel(label)
	query.SetAccessGroup(accessGroup)
	query.SetMatchLimit(MatchLimitOne)
	query.SetReturnData(true)
	results, err := QueryItem(query)
	if err != nil {
		return nil, err
	}
	if len(results) > 1 {
		return nil, fmt.Errorf("Too many results")
	}
	if len(results) == 1 {
		return results[0].Data, nil
	}
	return nil, nil
}
