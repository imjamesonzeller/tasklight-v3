// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/jamesonzeller/go/pkg/mod/github.com/wailsapp/wails/v3@v3.0.0-alpha.9/pkg/application/single_instance_darwin.go:1:1
//go:build darwin

package application

/*
#cgo CFLAGS: -x objective-c
#cgo LDFLAGS: -framework Foundation -framework Cocoa

#include <stdlib.h>
#import <Foundation/Foundation.h>
#import <Cocoa/Cocoa.h>

static void SendDataToFirstInstance(char *singleInstanceUniqueId, char* message) {
    [[NSDistributedNotificationCenter defaultCenter]
        postNotificationName:[NSString stringWithUTF8String:singleInstanceUniqueId]
        object:nil
        userInfo:@{@"message": [NSString stringWithUTF8String:message]}
        deliverImmediately:YES];
}

*/
import _ "unsafe"
import (
	"os"
	"syscall"
	"unsafe"
)

type darwinLock struct {
	file     *os.File
	uniqueID string
	manager  *singleInstanceManager
}

func newPlatformLock(manager *singleInstanceManager) (platformLock, error) {
	return &darwinLock{
		manager: manager,
	}, nil
}

func (l *darwinLock) acquire(uniqueID string) error {
	l.uniqueID = uniqueID
	lockFilePath := os.TempDir()
	lockFileName := uniqueID + ".lock"
	var err error
	l.file, err = createLockFile(lockFilePath + "/" + lockFileName)
	if err != nil {
		return alreadyRunningError
	}
	return nil
}

func (l *darwinLock) release() {
	if l.file != nil {
		syscall.Flock(int(l.file.Fd()), syscall.LOCK_UN)
		l.file.Close()
		os.Remove(l.file.Name())
		l.file = nil
	}
}

func (l *darwinLock) notify(data string) error {
	singleInstanceUniqueId := ( /*line :63:28*/_Cfunc_CString /*line :63:36*/)(l.uniqueID)
	defer func() func() { _cgo0 := /*line :64:15*/unsafe.Pointer(singleInstanceUniqueId); return func() { _cgoCheckPointer(_cgo0, nil); /*line :64:54*/_Cfunc_free(_cgo0); }}()()
	cData := ( /*line :65:11*/_Cfunc_CString /*line :65:19*/)(data)
	defer func() func() { _cgo0 := /*line :66:15*/unsafe.Pointer(cData); return func() { _cgoCheckPointer(_cgo0, nil); /*line :66:37*/_Cfunc_free(_cgo0); }}()()

	( /*line :68:2*/_Cfunc_SendDataToFirstInstance /*line :68:26*/)(singleInstanceUniqueId, cData)

	os.Exit(l.manager.options.ExitCode)
	return nil
}

// CreateLockFile tries to create a file with given name and acquire an
// exclusive lock on it. If the file already exists AND is still locked, it will
// fail.
func createLockFile(filename string) (*os.File, error) {
	file, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		return nil, err
	}

	err = syscall.Flock(int(file.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)
	if err != nil {
		file.Close()
		return nil, err
	}

	return file, nil
}

//export handleSecondInstanceData
func handleSecondInstanceData(secondInstanceMessage * /*line :93:54*/_Ctype_char /*line :93:60*/) {
	message := ( /*line :94:13*/_Cfunc_GoString /*line :94:22*/)(secondInstanceMessage)
	secondInstanceBuffer <- message
}
